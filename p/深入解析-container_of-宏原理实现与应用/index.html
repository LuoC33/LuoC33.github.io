<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="一、引言\r在 C 语言中，由于其本身缺乏如 C++ 的反射、类继承、成员指针反向查找等高级特性，开发者经常需要借助一些技巧来实现类似“对象关联”或“结构体成员反向定位”的功能。在 Linux 内核以及众多系统级 C 程序中，有一个极为重要且经典的宏，用于解决如下问题：\n已知一个结构体中的某个成员的指针，如何获取包含该成员的整个结构体的指针？\n这个问题的解决方案就是：container_of 宏。\n它不仅是 Linux 内核中数据结构（如链表、设备模型等）实现的基础工具，也是理解 C 语言指针运算、宏编程、类型系统和内存模型的极佳案例。\n二、container_of 的作用\r1. 问题背景\r在 C 语言中，我们常常定义如下的结构体：\n1struct Person { 2 int age; 3 char name[50]; 4 void *private_data; 5}; 当我们仅持有一个指向结构体某个成员的指针（例如 &amp;p.private_data）时，标准 C 并没有提供直接的方法来获取该成员所属的整个结构体对象的指针（例如 &amp;p）。\n2. container_of 的功能\rcontainer_of 宏 通过一个结构体成员的指针，计算并返回包含该成员的整个结构体的指针。\n换句话说，它是：\n一种通过“部分”信息（成员指针）反推出“整体”对象（宿主结构体）的机制。\n三、container_of 宏的标准实现\r在 Linux 内核中，container_of 宏通常定义为如下形式（使用 GCC 扩展语法）：\n1#define container_of(ptr, type, member) ({ \\ 2 const typeof(((type *)0)->member) *__mptr = (ptr); \\ 3 (type *)((char *)__mptr - offsetof(type, member)); \\ 4}) ⚠️ 注意：此实现使用了 GCC 的语句表达式（ ({ ... }) ） 与 typeof 关键字，属于 GCC 扩展语法，并非标准 C，但在 Linux 内核中被广泛采用。\n"><title>深入解析 container_of​ 宏：原理、实现与应用</title><link rel=canonical href=https://blog.liushuiyu.cn/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-container_of-%E5%AE%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/><link rel=stylesheet href=/scss/style.min.ae278c805800a943979bf29ae182404ef5a1e8351a2a4ccc3cc16f54ab699d33.css><meta property='og:title' content="深入解析 container_of\u200b 宏：原理、实现与应用"><meta property='og:description' content="一、引言\r在 C 语言中，由于其本身缺乏如 C++ 的反射、类继承、成员指针反向查找等高级特性，开发者经常需要借助一些技巧来实现类似“对象关联”或“结构体成员反向定位”的功能。在 Linux 内核以及众多系统级 C 程序中，有一个极为重要且经典的宏，用于解决如下问题：\n已知一个结构体中的某个成员的指针，如何获取包含该成员的整个结构体的指针？\n这个问题的解决方案就是：container_of 宏。\n它不仅是 Linux 内核中数据结构（如链表、设备模型等）实现的基础工具，也是理解 C 语言指针运算、宏编程、类型系统和内存模型的极佳案例。\n二、container_of 的作用\r1. 问题背景\r在 C 语言中，我们常常定义如下的结构体：\n1struct Person { 2 int age; 3 char name[50]; 4 void *private_data; 5}; 当我们仅持有一个指向结构体某个成员的指针（例如 &amp;p.private_data）时，标准 C 并没有提供直接的方法来获取该成员所属的整个结构体对象的指针（例如 &amp;p）。\n2. container_of 的功能\rcontainer_of 宏 通过一个结构体成员的指针，计算并返回包含该成员的整个结构体的指针。\n换句话说，它是：\n一种通过“部分”信息（成员指针）反推出“整体”对象（宿主结构体）的机制。\n三、container_of 宏的标准实现\r在 Linux 内核中，container_of 宏通常定义为如下形式（使用 GCC 扩展语法）：\n1#define container_of(ptr, type, member) ({ \\ 2 const typeof(((type *)0)->member) *__mptr = (ptr); \\ 3 (type *)((char *)__mptr - offsetof(type, member)); \\ 4}) ⚠️ 注意：此实现使用了 GCC 的语句表达式（ ({ ... }) ） 与 typeof 关键字，属于 GCC 扩展语法，并非标准 C，但在 Linux 内核中被广泛采用。\n"><meta property='og:url' content='https://blog.liushuiyu.cn/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-container_of-%E5%AE%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/'><meta property='og:site_name' content='liushuiyuのBlog'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Linux'><meta property='article:tag' content='编程'><meta property='article:published_time' content='2025-09-13T16:36:27+08:00'><meta property='article:modified_time' content='2025-09-13T16:36:27+08:00'><meta property='og:image' content='https://tuchuang.liushuiyu.cn/img/linux-0120250913.webp'><meta name=twitter:title content="深入解析 container_of\u200b 宏：原理、实现与应用"><meta name=twitter:description content="一、引言\r在 C 语言中，由于其本身缺乏如 C++ 的反射、类继承、成员指针反向查找等高级特性，开发者经常需要借助一些技巧来实现类似“对象关联”或“结构体成员反向定位”的功能。在 Linux 内核以及众多系统级 C 程序中，有一个极为重要且经典的宏，用于解决如下问题：\n已知一个结构体中的某个成员的指针，如何获取包含该成员的整个结构体的指针？\n这个问题的解决方案就是：container_of 宏。\n它不仅是 Linux 内核中数据结构（如链表、设备模型等）实现的基础工具，也是理解 C 语言指针运算、宏编程、类型系统和内存模型的极佳案例。\n二、container_of 的作用\r1. 问题背景\r在 C 语言中，我们常常定义如下的结构体：\n1struct Person { 2 int age; 3 char name[50]; 4 void *private_data; 5}; 当我们仅持有一个指向结构体某个成员的指针（例如 &amp;p.private_data）时，标准 C 并没有提供直接的方法来获取该成员所属的整个结构体对象的指针（例如 &amp;p）。\n2. container_of 的功能\rcontainer_of 宏 通过一个结构体成员的指针，计算并返回包含该成员的整个结构体的指针。\n换句话说，它是：\n一种通过“部分”信息（成员指针）反推出“整体”对象（宿主结构体）的机制。\n三、container_of 宏的标准实现\r在 Linux 内核中，container_of 宏通常定义为如下形式（使用 GCC 扩展语法）：\n1#define container_of(ptr, type, member) ({ \\ 2 const typeof(((type *)0)->member) *__mptr = (ptr); \\ 3 (type *)((char *)__mptr - offsetof(type, member)); \\ 4}) ⚠️ 注意：此实现使用了 GCC 的语句表达式（ ({ ... }) ） 与 typeof 关键字，属于 GCC 扩展语法，并非标准 C，但在 Linux 内核中被广泛采用。\n"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://tuchuang.liushuiyu.cn/img/linux-0120250913.webp'></head><body class=article-page style=display:flex;flex-direction:column><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><l1 class=site-name><a href=/>liushuiyuのBlog</a></l1></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li></ol><ol class=right-menu><a href=https://inde.lsyblog.live/ target=_blank class=travelling-button><li id=travelling><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" class="icon icon-tabler icons-tabler-filled icon-tabler-train"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 5c6.634.0 10.853 3.11 10.996 7.754L22 13a3 3 0 01-3 3H3a1 1 0 01-1-1V6a1 1 0 011-1zM7 7H4v3h3zm4 0H9v3h3V7.026A19 19 0 0011 7m3.001.257L14 10h5.04c-.979-1.337-2.689-2.306-5.039-2.743M21 18a1 1 0 010 2H3a1 1 0 010-2z"/></svg></li></a><li id=dark-mode-toggle><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" class="icon icon-tabler icons-tabler-filled icon-tabler-moon"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 1.992a10 10 0 109.236 13.838c.341-.82-.476-1.644-1.298-1.31A6.5 6.5.0 0113.074 3.733l.077-.08c.551-.63.113-1.653-.758-1.653h-.266l-.068-.006-.06-.002z"/></svg></li></ol></aside><div class="container main-container flex on-phone--column extended"><aside class=right-sidebar><div class=sticky-container><div class=author-sticky><div class=widget><div class=author><figure class=site-avatar><img src=https://tuchuang.liushuiyu.cn/img/leftwing.png class=left-wing alt="Left Wing">
<a href=/about/><img src=/img/avatar.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><img src=https://tuchuang.liushuiyu.cn/img/rightwing.png class=right-wing alt="Right Wing">
<span class=emoji>💖</span></figure><div class=site-meta><h1 class=about-site-name><a href=/about/>liushuiyu</a></h1><h2 class=about-site-description>那年分开的太仓促<br>我欠你一句话</h2><ol class=menu-social><li><img src=https://tuchuang.liushuiyu.cn/img/Wechatlogo.png alt=GitHub style=width:24px;height:24px></li><li><img src=https://tuchuang.liushuiyu.cn/img/QQlogo.png alt=GitHub style=width:24px;height:24px></li></ol></div></div></div><style>.author{background:var(--author-background)}.author{display:flex;justify-content:center;align-content:center;padding:0;border:none;height:300px}.author{border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);transition:.3s;position:relative;overflow:hidden;padding:1rem;display:flex;gap:8px;flex-direction:column;align-items:center}</style><style>.site-avatar{position:relative;margin:0;width:80px;height:80px;flex-shrink:0;margin-inline:auto;user-select:none;display:flex;align-items:center;justify-content:center}.site-avatar a img,.site-avatar .site-logo{border-radius:50%;position:relative;width:80px;height:80px;user-select:none}.site-avatar .left-wing{position:absolute;width:110px;height:auto;left:-105px;top:50%;transform:translateY(-60%);z-index:1;border-radius:0!important;user-select:none;pointer-events:none}.site-avatar .right-wing{position:absolute;width:110px;height:auto;right:-105px;top:50%;transform:translateY(-60%);z-index:1;border-radius:0!important;user-select:none;pointer-events:none}.site-avatar .emoji{position:absolute;width:25px;height:25px;line-height:25px;border-radius:100%;bottom:0;right:0;text-align:center;font-size:15px;background-color:var(--card-background);box-shadow:30px}.site-meta{display:flex;flex-direction:column;gap:10px;justify-content:center;margin-inline:auto;align-items:center;user-select:none}.about-site-name{color:#ecf0f1!important;margin:0;font-size:1.8rem;margin-top:10px;user-select:none}.about-site-name a{color:#ecf0f1!important}.about-site-description{margin-left:15px;color:rgba(255,255,255,.7);font-weight:400;margin-top:0;font-size:1.6rem;user-select:none;text-align:center}.menu-social svg{stroke:rgba(255,255,255,.7)}.author{background:var(--author-background);display:flex;justify-content:center;align-content:center;padding:0;border:none;height:300px;border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);transition:.3s;position:relative;overflow:visible;padding:1rem;display:flex;gap:8px;flex-direction:column;align-items:center}</style></div><div class=toc-sticky><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#一引言>一、引言</a></li><li><a href=#二container_of-的作用>二、<code>container_of</code> 的作用</a><ol><li><a href=#1-问题背景>1. 问题背景</a></li><li><a href=#2-container_of-的功能>2. <code>container_of</code> 的功能</a></li></ol></li><li><a href=#三container_of-宏的标准实现>三、<code>container_of</code> 宏的标准实现</a></li><li><a href=#四container_of-的组成与工作原理>四、<code>container_of</code> 的组成与工作原理</a><ol><li><a href=#1-宏接口说明>1. 宏接口说明</a></li><li><a href=#2-宏的工作目标>2. 宏的工作目标</a></li><li><a href=#3-核心实现原理>3. 核心实现原理</a></li></ol></li><li><a href=#五offsetof-宏偏移量计算的核心>五、<code>offsetof</code> 宏：偏移量计算的核心</a><ol><li><a href=#1-什么是-offsetof>1. 什么是 <code>offsetof</code>？</a></li><li><a href=#2-offsetof-的标准实现>2. <code>offsetof</code> 的标准实现</a><ol><li><a href=#详细解析>详细解析：</a></li></ol></li><li><a href=#3-为什么-offsetof-是安全的>3. 为什么 <code>offsetof</code> 是安全的？</a></li></ol></li><li><a href=#六container_of-宏的逐步解析>六、<code>container_of</code> 宏的逐步解析</a><ol><li><a href=#步骤解析>步骤解析：</a></li></ol></li><li><a href=#七完整示例代码>七、完整示例代码</a><ol><li><a href=#输出示例>输出示例：</a></li></ol></li><li><a href=#八关键技术与疑难点解析>八、关键技术与疑难点解析</a><ol><li><a href=#1-为什么需要-container_of>1. 为什么需要 <code>container_of</code>？</a></li><li><a href=#3-offsetof-的实现安全吗>3. <code>offsetof</code> 的实现安全吗？</a></li><li><a href=#4-container_of-返回的是什么>4. <code>container_of</code> 返回的是什么？</a></li><li><a href=#5-为什么使用-typeof在-gcc-版本中>5. 为什么使用 <code>typeof</code>（在 GCC 版本中）？</a></li></ol></li><li><a href=#九总结>九、总结</a></li></ol></nav></div></section></div></div></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-container_of-%E5%AE%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/><img src=https://tuchuang.liushuiyu.cn/img/linux-0120250913.webp loading=lazy alt="Featured image of post 深入解析 container_of​ 宏：原理、实现与应用"></a></div><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-container_of-%E5%AE%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/>深入解析 container_of​ 宏：原理、实现与应用</a></h2></div><footer class=article-time><header class=article-category><a href=/categories/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B/>代码编程</a></header><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2025-9-13</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 3 分钟</time></div></footer></div></header><section class=article-content><h2 id=一引言>一、引言</h2><p>在 C 语言中，由于其本身缺乏如 C++ 的反射、类继承、成员指针反向查找等高级特性，开发者经常需要借助一些技巧来实现类似“对象关联”或“结构体成员反向定位”的功能。在 Linux 内核以及众多系统级 C 程序中，有一个极为重要且经典的宏，用于解决如下问题：</p><blockquote><p><strong>已知一个结构体中的某个成员的指针，如何获取包含该成员的整个结构体的指针？</strong></p></blockquote><p>这个问题的解决方案就是：<strong><code>container_of</code></strong> <strong>宏</strong>。</p><p>它不仅是 Linux 内核中数据结构（如链表、设备模型等）实现的基础工具，也是理解 C 语言指针运算、宏编程、类型系统和内存模型的极佳案例。</p><hr><h2 id=二container_of-的作用>二、<code>container_of</code> 的作用</h2><h3 id=1-问题背景>1. 问题背景</h3><p>在 C 语言中，我们常常定义如下的结构体：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=k>struct</span> <span class=n>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=kt>int</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>50</span><span class=p>];</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>private_data</span><span class=p>;</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=p>};</span></span></span></code></pre></div><p>当我们仅持有一个指向结构体<strong>某个成员</strong>的指针（例如 <code>&amp;p.private_data</code>）时，标准 C 并没有提供直接的方法来获取该成员所属的<strong>整个结构体对象</strong>的指针（例如 <code>&amp;p</code>）。</p><h3 id=2-container_of-的功能>2. <code>container_of</code> 的功能</h3><p><code>container_of</code> 宏 <strong>通过一个结构体成员的指针，计算并返回包含该成员的整个结构体的指针</strong>。</p><p>换句话说，它是：</p><blockquote><p>一种通过“部分”信息（成员指针）反推出“整体”对象（宿主结构体）的机制。</p></blockquote><hr><h2 id=三container_of-宏的标准实现>三、<code>container_of</code> 宏的标准实现</h2><p>在 Linux 内核中，<code>container_of</code> 宏通常定义为如下形式（使用 GCC 扩展语法）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=cp>#define container_of(ptr, type, member) ({              \
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=cp>    const typeof(((type *)0)-&gt;member) *__mptr = (ptr);  \
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=cp>    (type *)((char *)__mptr - offsetof(type, member));  \
</span></span></span><span class=line><span class=ln>4</span><span class=cl><span class=cp>})</span></span></span></code></pre></div><blockquote><p>⚠️ 注意：此实现使用了 <strong>GCC 的语句表达式（</strong> <strong><code>({ ... })</code></strong> <strong>）</strong> 与 <strong><code>typeof</code></strong> <strong>关键字</strong>，属于 <strong>GCC 扩展语法</strong>，并非标准 C，但在 Linux 内核中被广泛采用。</p></blockquote><p>若需编写更具可移植性、符合标准 C 的版本，可简化为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=cp>#define container_of(ptr, type, member) \
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=cp>    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span></span></code></pre></div><p>下面我们将围绕这个宏，深入讲解它的<strong>组成、原理、关键点与实现细节</strong>。</p><hr><h2 id=四container_of-的组成与工作原理>四、<code>container_of</code> 的组成与工作原理</h2><h3 id=1-宏接口说明>1. 宏接口说明</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=ln>1</span><span class=cl>container_of(ptr, type, member)</span></span></code></pre></div><div class=table-wrapper><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>ptr</code></td><td>指向结构体中某个成员的指针（例如<code>&amp;p.private_data</code>）</td></tr><tr><td><code>type</code></td><td>该成员所属的结构体类型（例如<code>struct Person</code>）</td></tr><tr><td><code>member</code></td><td>该成员在结构体中的名称（例如<code>private_data</code>）</td></tr></tbody></table></div><h3 id=2-宏的工作目标>2. 宏的工作目标</h3><p>通过传入的成员指针 <code>ptr</code>，计算并返回包含该成员的<strong>整个结构体对象的指针</strong>。</p><hr><h3 id=3-核心实现原理>3. 核心实现原理</h3><p><code>container_of</code> 的实现依赖于以下两个关键技术：</p><ol><li><strong><code>offsetof(type, member)</code></strong> <strong>：计算成员在结构体中的偏移字节数</strong></li><li><strong>指针运算：通过成员指针减去其偏移量，反推出结构体起始地址</strong></li></ol><hr><h2 id=五offsetof-宏偏移量计算的核心>五、<code>offsetof</code> 宏：偏移量计算的核心</h2><h3 id=1-什么是-offsetof>1. 什么是 <code>offsetof</code>？</h3><blockquote><p><code>offsetof(type, member)</code> 是一个<strong>宏</strong>，用于计算结构体 <code>type</code> 中的成员 <code>member</code> 相对于结构体起始地址的<strong>偏移字节数</strong>。</p></blockquote><p>例如，如果结构体起始地址为 <code>0x1000</code>，而成员 <code>private_data</code> 的地址为 <code>0x1036</code>，那么：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=nf>offsetof</span><span class=p>(</span><span class=k>struct</span> <span class=n>Person</span><span class=p>,</span> <span class=n>private_data</span><span class=p>)</span> <span class=o>==</span> <span class=mh>0x36</span>  <span class=c1>// 即 54 字节
</span></span></span></code></pre></div><hr><h3 id=2-offsetof-的标准实现>2. <code>offsetof</code> 的标准实现</h3><p>在大多数标准 C 库（如 glibc）和编译器中，<code>offsetof</code> 的实现通常如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=ln>1</span><span class=cl>#define offsetof(type, member) ((size_t) &amp;((type *)0)-&gt;member)</span></span></code></pre></div><h4 id=详细解析>详细解析：</h4><ul><li><p><code>(type *)0</code>：将整数值 <code>0</code> 强制转换为一个指向 <code>type</code> 类型的指针。它表示 <strong>“假设存在一个 type 类型的对象，其地址为 0”</strong> 。</p><p>⚠️ <strong>注意：这里并没有真的访问地址 0 的内存，只是构造了一个指针用于类型推导和偏移计算。</strong></p></li><li><p><code>((type *)0)->member</code>：访问该（假设）对象的成员 <code>member</code>。</p></li><li><p><code>&((type *)0)->member</code>：<strong>取该成员的地址</strong>。由于结构体假设位于地址 0，因此该地址的值就是成员相对于结构体起始地址的<strong>偏移字节数</strong>。</p></li><li><p><code>(size_t)</code>：将得到的地址值（指针）强制转换为 <code>size_t</code> 类型（一种无符号整型，通常用于表示大小或偏移），最终得到一个整数，表示成员在结构体中的偏移量。</p></li></ul><hr><h3 id=3-为什么-offsetof-是安全的>3. 为什么 <code>offsetof</code> 是安全的？</h3><p>尽管代码中出现了 <code>(type *)0</code>，但由于我们<strong>仅用它来计算成员的地址，而并未真正解引用该指针去访问内存</strong>，因此：</p><p>✅ 它是<strong>编译期完成的计算</strong>
✅ 它<strong>不会在运行时访问地址 0 的内存</strong>
✅ 它是<strong>安全且被标准广泛接受的做法</strong></p><hr><h2 id=六container_of-宏的逐步解析>六、<code>container_of</code> 宏的逐步解析</h2><p>以如下调用为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=k>struct</span> <span class=n>Person</span> <span class=o>*</span><span class=n>p_ptr</span> <span class=o>=</span> <span class=nf>container_of</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=p>.</span><span class=n>private_data</span><span class=p>,</span> <span class=k>struct</span> <span class=n>Person</span><span class=p>,</span> <span class=n>private_data</span><span class=p>);</span></span></span></code></pre></div><p>假设该宏展开后为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=p>(</span><span class=n>type</span> <span class=o>*</span><span class=p>)((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>__mptr</span> <span class=o>-</span> <span class=nf>offsetof</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>member</span><span class=p>))</span></span></span></code></pre></div><h3 id=步骤解析>步骤解析：</h3><ol><li><p><strong>输入：</strong></p><ul><li><code>ptr</code> 是指向成员的指针，例如 <code>&amp;p.private_data</code></li><li><code>type</code> 是结构体类型，例如 <code>struct Person</code></li><li><code>member</code> 是成员名称，例如 <code>private_data</code></li></ul></li><li><p><strong>计算成员偏移量：</strong></p><ul><li>调用 <code>offsetof(type, member)</code>，得到成员 <code>private_data</code> 在结构体中的偏移字节数（例如 54）</li></ul></li><li><p><strong>将成员指针转换为字节指针：</strong></p><ul><li>将 <code>ptr</code>（可能为 <code>void *</code> 类型）强制转换为 <code>char *</code>，因为 <code>char</code> 的大小为 1 字节，便于进行<strong>按字节精确计算</strong></li></ul></li><li><p><strong>计算结构体起始地址：</strong></p><ul><li>用成员指针的地址，减去该成员的偏移量，得到结构体的起始地址</li></ul></li><li><p><strong>类型转换：</strong></p><ul><li>将计算出的地址强制转换回结构体类型指针，如 <code>(struct Person *)</code>，从而得到指向整个结构体的指针</li></ul></li></ol><hr><h2 id=七完整示例代码>七、完整示例代码</h2><p>下面是一个完整、可运行的示例程序，演示 <code>container_of</code> 的使用与原理：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stddef.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=c1>// 定义 container_of 宏（标准 C 兼容版本）
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=c1></span><span class=cp>#define container_of(ptr, type, member) \
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=cp>    ((type *)((char *)(ptr) - offsetof(type, member)))
</span></span></span><span class=line><span class=ln> 7</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=c1>// 定义测试结构体
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=kt>int</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>    <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>50</span><span class=p>];</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>private_data</span><span class=p>;</span>
</span></span><span class=line><span class=ln>13</span><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>
</span></span><span class=line><span class=ln>15</span><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>    <span class=k>struct</span> <span class=n>Person</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>    <span class=n>p</span><span class=p>.</span><span class=n>age</span> <span class=o>=</span> <span class=mi>25</span><span class=p>;</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>    <span class=nf>snprintf</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>name</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>name</span><span class=p>),</span> <span class=s>&#34;Alice&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>    <span class=n>p</span><span class=p>.</span><span class=n>private_data</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mh>0xDEADBEEF</span><span class=p>;</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>
</span></span><span class=line><span class=ln>21</span><span class=cl>    <span class=c1>// 获取成员 private_data 的指针
</span></span></span><span class=line><span class=ln>22</span><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>p</span><span class=p>.</span><span class=n>private_data</span><span class=p>;</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>
</span></span><span class=line><span class=ln>24</span><span class=cl>    <span class=c1>// 通过 container_of 获取包含该成员的结构体指针
</span></span></span><span class=line><span class=ln>25</span><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>Person</span> <span class=o>*</span><span class=n>p_found</span> <span class=o>=</span> <span class=nf>container_of</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=k>struct</span> <span class=n>Person</span><span class=p>,</span> <span class=n>private_data</span><span class=p>);</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>
</span></span><span class=line><span class=ln>27</span><span class=cl>    <span class=c1>// 输出验证
</span></span></span><span class=line><span class=ln>28</span><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Original person   : %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=ln>29</span><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Found person      : %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p_found</span><span class=p>);</span>
</span></span><span class=line><span class=ln>30</span><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Member private_data: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p_found</span><span class=o>-&gt;</span><span class=n>private_data</span><span class=p>);</span>
</span></span><span class=line><span class=ln>31</span><span class=cl>
</span></span><span class=line><span class=ln>32</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p_found</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>33</span><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;✅ container_of 成功找到了原始结构体！</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>34</span><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>35</span><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;❌ 错误：未正确找到结构体</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>36</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>37</span><span class=cl>
</span></span><span class=line><span class=ln>38</span><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>39</span><span class=cl><span class=p>}</span></span></span></code></pre></div><h3 id=输出示例>输出示例：</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=ln>1</span><span class=cl>Original person   : 0x7ffd12345678
</span></span><span class=line><span class=ln>2</span><span class=cl>Found person      : 0x7ffd12345678
</span></span><span class=line><span class=ln>3</span><span class=cl>Member private_data: 0xdeadbeef
</span></span><span class=line><span class=ln>4</span><span class=cl>✅ container_of 成功找到了原始结构体！</span></span></code></pre></div><hr><h2 id=八关键技术与疑难点解析>八、关键技术与疑难点解析</h2><h3 id=1-为什么需要-container_of>1. 为什么需要 <code>container_of</code>？</h3><p>C 语言没有内置的机制可以从成员指针反推宿主结构体指针。而实际开发中（尤其是在实现通用容器、链表、面向对象风格的代码时），这一功能极其重要。</p><hr><h3 id=3-offsetof-的实现安全吗>3. <code>offsetof</code> 的实现安全吗？</h3><p>✅ 是的。虽然它使用了 <code>(type *)0</code>，但<strong>仅用于计算成员地址，而并未真正访问该地址的内存</strong>，因此是安全的。</p><hr><h3 id=4-container_of-返回的是什么>4. <code>container_of</code> 返回的是什么？</h3><p>它返回一个 <strong>指向结构体的指针</strong>，类型为 <code>type *</code>，即你传入的结构体类型。</p><p>它<strong>不是常数，也不是宏直接替换为值</strong>，而是在预处理阶段展开为一段代码，最终在运行时计算并返回一个指针。</p><hr><h3 id=5-为什么使用-typeof在-gcc-版本中>5. 为什么使用 <code>typeof</code>（在 GCC 版本中）？</h3><p><code>typeof</code> 用于<strong>自动推导成员的类型</strong>，使得 <code>container_of</code> 宏可以适用于<strong>任意结构体和任意成员</strong>，具有高度的通用性。标准 C 中可用显式类型替代，但通用性会降低。</p><hr><h2 id=九总结>九、总结</h2><div class=table-wrapper><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>通过结构体成员的指针，获取包含该成员的整个结构体的指针</td></tr><tr><td><strong>核心原理</strong></td><td>成员指针 - 成员偏移量 = 结构体起始地址</td></tr><tr><td><strong>关键宏</strong></td><td><code>offsetof(type, member)</code>：计算成员偏移量</td></tr><tr><td><strong>实现方式</strong></td><td>指针运算：<code>(char *)member_ptr - offsetof(...)</code></td></tr><tr><td><strong>典型应用</strong></td><td>Linux 内核链表、设备模型、通用容器、面向对象风格代码</td></tr><tr><td><strong>扩展知识</strong></td><td>涉及指针类型转换、宏编程、编译期计算、内存模型等 C 语言高级主题</td></tr></tbody></table></div></section><div class=post-reward data-html2canvas-ignore><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=https://tuchuang.liushuiyu.cn/img/wxzf.webp>
<span>微信打赏</span>
</label><label class=qr-code-image for=reward><img class=image src=https://tuchuang.liushuiyu.cn/img/zfbzf.webp>
<span>支付宝打赏</span></label></div></div><footer class=article-footer><section class=article-tags><a href=/tags/linux/>Linux</a>
<a href=/tags/%E7%BC%96%E7%A8%8B/>编程</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class="article-card has-image"><a href=/p/%E7%94%A8-gcc-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%BA%E5%88%B6/><div class=article-image><img src=https://tuchuang.liushuiyu.cn/img/c-jingjie-logo320250911.webp loading=lazy data-key data-hash=https://tuchuang.liushuiyu.cn/img/c-jingjie-logo320250911.webp></div><div class=article-details><h2 class=article-title>用 GCC 实现模块自动注册初始化机制</h2></div></a></article><article class="article-card has-image"><a href=/p/c%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E5%86%85%E5%AD%98%E4%B8%8Eunion%E7%9A%84%E5%AE%8C%E7%BE%8E%E7%BB%93%E5%90%88/><div class=article-image><img src=https://tuchuang.liushuiyu.cn/img/c-jingjie-logo220250902.webp loading=lazy data-key data-hash=https://tuchuang.liushuiyu.cn/img/c-jingjie-logo220250902.webp></div><div class=article-details><h2 class=article-title>C语言进阶：内存与union的完美结合</h2></div></a></article><article class="article-card has-image"><a href=/p/c%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%E5%AE%8F%E5%9C%A8log%E8%B0%83%E8%AF%95%E4%B8%AD%E7%9A%84%E8%89%BA%E6%9C%AF/><div class=article-image><img src=https://tuchuang.liushuiyu.cn/img/c-jingjie-logo20250901.webp loading=lazy data-key data-hash=https://tuchuang.liushuiyu.cn/img/c-jingjie-logo20250901.webp></div><div class=article-details><h2 class=article-title>C语言进阶教程：宏在Log调试中的艺术</h2></div></a></article><article class="article-card has-image"><a href=/p/c-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88unique_ptr%E4%B8%8Emake_unique/><div class=article-image><img src=https://tuchuang.liushuiyu.cn/img/ptr-logo20250901.webp loading=lazy data-key data-hash=https://tuchuang.liushuiyu.cn/img/ptr-logo20250901.webp></div><div class=article-details><h2 class=article-title>C++智能指针unique_ptr​与make_unique</h2></div></a></article><article class="article-card has-image"><a href=/p/c-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/><div class=article-image><img src=https://tuchuang.liushuiyu.cn/img/copy-logo20250831.webp loading=lazy data-key data-hash=https://tuchuang.liushuiyu.cn/img/copy-logo20250831.webp></div><div class=article-details><h2 class=article-title>C++构造函数与拷贝控制完全指南</h2></div></a></article></div></div></aside><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script src=https://blog.liushuiyu.cn/background/sakura.js></script><style>#TableOfContents>ul,ol{ul, ol { display: none; } .open { display: block; }}</style><script>function initTocHide(){let e=document.querySelector(".widget--toc");if(!e)return;window.addEventListener("scroll",function(){let t=document.querySelector(".active-class");if(!t)return;let n=document.querySelectorAll(".open");n.length>0&&n.forEach(e=>{e.classList.remove("open")}),t.children.length>1&&t.children[1].classList.add("open");let e=t.parentElement;do e.classList.add("open"),e=e.parentElement.parentElement;while(e!==0[0]&&(e.localName==="ul"||e.localName==="ol"))})}initTocHide()</script><style>footer.site-footer{width:100%;position:relative;bottom:0;padding:20px 10px;font-size:1.3rem;font-weight:600;line-height:1.75;color:var(--card-text-color-secondary);background-color:var(--footer-bg);box-shadow:0 -3px 1px -3px var(--card-text-color-main);padding:10px;user-select:none}.footer-info{display:grid;grid-template-columns:1fr auto}.right-footer{text-align:left;display:flex;align-items:right}footer.site-footer a{font-size:15px;color:var(--card-text-color-main);transition:color .2s ease-in-out;margin-inline:15px}.copyright{font-size:15px;color:var(--card-text-color-main)!important;transition:color .2s ease-in-out;margin-inline:15px}</style><div style=display:flex;justify-content:center;align-items:center;flex-direction:column;margin-top:60px;color:var(--card-text-color-main);margin:30px></div><footer class=site-footer><div class=footer-info><div class=left-footer><section class=copyright>&copy;
2024 -
2025 liushuiyu</section></div><section class=totalcount>发表了16篇文章 ·
总计6.33k字</section></div></footer></body></html>