[{"content":"过往已去，是非对错我已无心解释 偶然读了一篇小短文《以樱桃之名成长》，作者：南雪。直白、精练的语言流露了单恋的苦涩和遗憾。\n原文 第一颗樱桃：单恋\n17岁，我上高中。爱上了一个男生。我没告诉他。高考，那个男生落了榜，卖掉了高中参考书，要远走西藏。那天，我到学校拿录取通知书，在校门口见他守在一大堆书前，身边一个穿蓝衣的老头儿，用秤称一沓沓书的重量。那一天，他卖掉的书中，有一本崭新的、从未翻阅过的《朱自清散文选》。在老头儿那里，我将书买了回来，花2元钱，原书的十分之一的价钱。回家，翻到了第20页，那儿写着小小的一行字：我喜欢你。清楚的四个字，他没有看到。他是不喜欢朱自清的人。那本书，是我送给他的，那行字是我写的。 很久很久以后，我知道，在一个不爱的人眼中，单恋的价格如同打哈欠时流出的眼泪，廉价，刚开始时是19块8，后来是2块。\n","date":"2024-10-01T17:24:57+08:00","image":"https://tu1.lsyblog.live/img/%E5%8D%95%E6%81%8B.webp","permalink":"https://LuoC33.github.io/p/%E7%AC%AC%E4%B8%80%E9%A2%97%E6%A8%B1%E6%A1%83%E5%8D%95%E6%81%8B/","title":"第一颗樱桃：单恋"},{"content":"了解工具链 明白什么是工具链 工具链，官方来说，是指用于将源代码转换为可执行程序的一系列工具的集合。通俗地理解，就是开发过程中使用的工具集合。一般情况下，工具链主要指狭义的部分，包括编译器（如GCC、G++）、构建工具以及开发环境（如IDE：VSCode、CLion等）。开发系统（如Windows、Linux、MacOS）也可以视为支撑工具链的一部分。\n这么说能理解吗？就好比你要吃饭，得先要用水洗米，然后装水后再用电饭锅煮米对吧？在这个过程中，你用到的水、电、电饭锅都是工具链中的一环。\n为什么要来了解工具链 对于入门菜鸟来说，他所学的，他所看到的，未必是全面和绝对正确的，纵观各大教程，很少人会真正的去引导一个刚刚入门计算机、刚学习编程的小白菜鸟。\n工具链的理解我认为是新手必不可少的一部分，如下面代码：\n1//只有Gcc工具链的编译器才能执行 2#include \u0026lt;stdio.h\u0026gt; 3 4int main() { 5 int n; 6 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 8 // 可变长数组 9 int arr[n]; 10 11 // 初始化数组 12 for (int i = 0; i \u0026lt; n; i++) { 13 arr[i] = i * i; 14 } 15 16 // 打印数组 17 printf(\u0026#34;Array elements are:\\n\u0026#34;); 18 for (int i = 0; i \u0026lt; n; i++) { 19 printf(\u0026#34;%d \u0026#34;, arr[i]); 20 } 21 22 printf(\u0026#34;\\n\u0026#34;); 23 24 return 0; 25} 可以拿这段代码去各个IDE跑一跑，你就会发现，有的IDE会报错，而有的IDE就能过。\n这其实就是工具链不同而导致的一些小差异，反正在我初学C语言的时候，就去网上找到一些有意思的代码，复制下来直接跑（如烟花大爆炸、 代码雨）但是很多时候都会遇上一路报红。\n这其实不是代码有问题，也不是你的电脑有问题，而是单纯的你们开发环境不一致导致的。\n更加离谱的是下面的 代码：\n1 2#include \u0026lt;stdio.h\u0026gt; 3 4int main(void) { 5 long double arr[100]; 6 scanf(\u0026#34;%lf\u0026#34;,\u0026amp;arr); 7 printf(\u0026#34;%lf\u0026#34;,arr); 8 return 0; 9} 你会发现这段代码，在VScode和DevC++上跑出来的结果始终为0.000,其实原因就是因为他们用的工具链是GCC，如果你用的是VS，那就能跑出正确的结果，因为VS用的是MSVC。\n你可能在看教学视频的时候，用的不是和博主同一个ide来写代码，这时候如果你去复现他的代码，可能就会出现我刚才举的这两个例子。\n你复现不出来，你会百思不得其解，其实是你一开始你就已经抛空了你学习的地基，你都不知道C语言能够被编译执行的流程和原理，你就会学得迷迷糊糊，或许你是练武天才，这种倒逆行施下没走火入魔也可以说是 韧性不错。\n到目前为止，我从未遇见过能把C或C++学得扎实的，遇见的更多都是，一入门跟着视频就走，学了判断，学了循环，或许又学了函数和一点指针就开始刷Oj了。\n这是真的学好了C吗？你Oj哪怕刷了一千题、一万题、一百万题，我都说没用。Oj更偏向数学算法，编程只是来实现这个算法的，你会基本的语法就行。 你让一个专打Oj的用C来做简单操作系统、网络应用、数据库引擎的部分功能，他可能会摇摇头。\n算法对软件开发也好，对嵌入式技术也好，都是必不可少的，只不过在嵌入式技术中，算法能力要求的没软件开发那边那么高。\n过于用Oj来评判自己编程基础我觉得是倒反天罡，真正先把底子学好了，摸清楚了框架，你到那时候才会明白算法对你的意义。\n我拿嵌入式这方面举例，你做了一个运动分析，跟踪手部动作的\n","date":"2024-09-26T22:45:35+08:00","image":"https://tu1.lsyblog.live/img/C%E8%AF%AD%E8%A8%80%E5%B7%A5%E5%85%B7%E9%93%BE.png","permalink":"https://LuoC33.github.io/p/c%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8--%E5%B7%A5%E5%85%B7%E9%93%BE/","title":"C语言入门--工具链"},{"content":"实现功能： 能够实现自动识别黑线，完成5路循迹。 能够通过蓝牙于89C52系列芯片串口通信控制小车 能够自动感应障碍物实现自动刹停。 准备材料： 89C52芯片及最小系统板 ， L298n模块， 模拟量5路循迹模块, 稳压模块， HC-06模块， 超声波模块， 亚巧克力板， 4个电机， 12vDC电源， DC转接母头 普通小车使能实现原理： 利用51单片机IO口控制L298n模块引脚供电实现对电机触发。再通过EN使能端进行PWM调速，实现转弯，漂移，转圈等特殊转速。\nIN为L298N模块控制引脚\nEN为L298N模块使能引脚\nL298N模块单边IN为0,0时，电机停止转动，为1,0 、0,1时正转、反转\n1#include \u0026lt;REGX52.H\u0026gt; 2unsigned char Duty_left,Duty_right,j=0,i=0; 3//l298n 4sbit IN11=P0^2;//左前轮 5sbit IN12=P0^1; 6 7sbit IN13=P0^3;//右前轮 8sbit IN14=P0^4; 9 10sbit IN21=P1^1;//左后轮 11sbit IN22=P1^2; 12 13sbit IN23=P1^4;//右后轮 14sbit IN24=P1^3; 15 16//使能端 17sbit EN1A=P0^0;//左前 18sbit EN1B=P0^5;//右前1 19sbit EN2A=P1^6;//左后 20sbit EN2B=P1^7;//右后1 21 22 //定时器+中断 23void Timer0_Init()\t//100微秒@11.0592MHz 24{ 25 TMOD|=0x01;//定时器T0，，工作方式都为方式1 26 TH0=0xff;//定时ff9c0.1ms fe0c0.5ms 27 TL0=0x9c; 28 29 EA=1; //开启总中断 30 ET0=1;//开启中断允许 31 TR0=1;//开启定时器中断 32} 33//利用中断，PWM调速 34void Timer0_Routine() interrupt 1 35{ 36 TH0=0xff;//定时ff9c0.1ms fe0c0.5ms 37 TL0=0x9c; 38\t39 i++; 40 j++; 41 42if(i\u0026lt;=Duty_left) 43\t{ 44\tEN1A=1; 45\tEN2A=1; 46\t} 47else 48\t{ 49\tEN1A=0; 50\tEN2A=0; 51\t} 52if(j\u0026lt;=Duty_right) 53\t{ 54\tEN1B=1; 55\tEN2B=1; 56\t} 57else 58\t{ 59\tEN1B=0; 60\tEN2B=0; 61\t} 62\t63\tif(i==100) //设置pwm周期=0.1ms*100=10ms,这样开头定义的变量正好表示占空比数值 64 { 65 i=0;//加到100后变为0，重新计数 66 } 67 if(j==100) //设置pwm周期=0.1ms*100=10ms,这样开头定义的变量正好表示占空比数值 68 { 69 j=0; 70 } 71 72} 蓝牙小车原理： 通过将蓝牙模块的{% label TX %}与{% label RX %}与单片机交叉相接进行串口通信，实现收发数据。\n1#include \u0026lt;REGX52.H\u0026gt; 2//l298n 3sbit IN11=P0^2;//左前轮 4sbit IN12=P0^1; 5 6sbit IN13=P0^3;//右前轮 7sbit IN14=P0^4; 8 9sbit IN21=P1^1;//左后轮 10sbit IN22=P1^2; 11 12sbit IN23=P1^4;//右后轮 13sbit IN24=P1^3; 14 15char i; 16unsigned char ReceiveData; //接收到的数据存放变量 17//向左转 18void correct_left() 19{ 20 IN11=0; 21 IN12=0; 22\tIN21=0; 23 IN22=0; 24\t25 IN13=1; 26 IN14=0; 27\tIN23=1; 28 IN24=0; 29 30 31} 32//向右转 33void correct_right() 34{ 35 IN11=1; 36 IN12=0; 37\tIN21=1; 38 IN22=0; 39\t40 IN13=0; 41 IN14=0; 42\tIN23=0; 43 IN24=0; 44 45 46} 47 48//左转 49void Left_turning() 50{ 51 52 IN11=0; 53 IN12=1; 54 IN21=0; 55 IN22=1; 56\t57 IN13=1; 58 IN14=0; 59 IN23=1; 60 IN24=0; 61} 62//右转 63void Right_turning() 64{ 65 66 IN11=1; 67 IN12=0; 68 IN21=1; 69 IN22=0; 70\t71 IN13=0; 72 IN14=1; 73 IN23=0; 74 IN24=1; 75} 76//小车直走前行，不拐弯速度赋值 77void forward_move() 78{ 79 80 IN11=1; 81 IN12=0; 82 IN21=1; 83 IN22=0; 84\t85 IN13=1; 86 IN14=0; 87 IN23=1; 88 IN24=0; 89} 90 91void back() 92{ 93 94 IN11=0; 95 IN12=1; 96 IN21=0; 97 IN22=1; 98\t99 IN13=0; 100 IN14=1; 101 IN23=0; 102 IN24=1; 103} 104 105void stop() 106{ 107 108 IN11=0; 109 IN12=0; 110 IN21=0; 111 IN22=0; 112\t113 IN13=0; 114 IN14=0; 115 IN23=0; 116 IN24=0; 117} 118 119 120 121void receive(unsigned char m)//执行函数 122{ 123\tswitch(m) 124\t{ 125\tcase \u0026#39;8\u0026#39;:forward_move();break; 126\tcase \u0026#39;5\u0026#39;:stop();break;//停止 127\t} 128} 129 130void Uart_Init()\t//9600bps@11.0592MHz 131{ 132\tPCON = 0x00;\t//波特率不倍速s 133\tSCON = 0x50;\t//8位数据,可变波特率 134\tTMOD = 0x20;\t//设定定时器1为8位自动重装方式 135\tTL1 = 0xFD;\t//设定定时初值 136\tTH1 = 0xFD;\t//设定定时器重装值 137\tET1 = 0;\t//禁止定时器1中断 138\tTR1 = 1;\t//启动定时器1 139\tEA=1; //总中断 140\tES=1; //打开串口中断 141} 142 143void Uart_Routine() interrupt 4 //中断 144{ 145 stop(); 146 RI=0; //清除接收中断标志位 147 ReceiveData=SBUF; //除去接受的数据 148\treceive(ReceiveData); 149} 150 151void main() 152{ 153\tUart_Init(); 154\twhile(1); 155} 超声波急停避障小车原理： 1.采用 IO 口 {% label TRIG %} 触发测距，给一个 10us 的高电平信号；\n2.模块自动发送 8 个 40khz 的方波，自动检测是否有信号返回；\n3.有信号返回，通过 IO 口 {% label ECHO %} 输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间。\n4.测试距离=（高电平时间*声速（340M/S））/2\n{% image https://img2.imgtp.com/2024/05/29/C0lSwYoH.png, alt= %}\n1#include \u0026lt;REGX52.H\u0026gt; 2#include \u0026#34;delay.h\u0026#34; 3sbit Trig=P3^3;//定义超声波模块引脚 4sbit Echo=P3^2; 5unsigned int a,distance; 6 7int csb() 8{\t9 10\t11\tTMOD \u0026amp;= 0x0F;\t//设置定时器模式 12\t13\tTL1 = 0;\t//设置定时初始值 14\tTH1 = 0;\t//设置定时初始值 15\t16\t17\tTrig=1;//发射20US的脉冲 18 Delay10us(2); 19 Trig=0;//关闭 20\t21\t22 while(!Echo);//等待返回脉冲 23 TR1=1; 24 while(!Echo);//返回脉冲结束 25 TR1=0; 26\t27 a=TH1*256+TL1; 28 TH1=0; 29 TL1=0; 30\t31 distance= a*1.7/100; //计算公式，按照数据手册为准，不同环境不同计算方法。 32\t33\tTrig=0; 34\tEcho=0; 35\treturn distance; 36} 37 5路PID循迹小车原理： {% image https://img2.imgtp.com/2024/05/29/jT3cO80Q.png, alt= %}\n简单的循迹就是通过循迹模块反馈给单片机的高低电平信号进行不断判断和迭代，列出全部情况，这里就不做赘述。在此分享和学习关于PID算法循迹。\n1#include \u0026lt;REGX52.H\u0026gt; 2 3// 定义PID控制的参数 4float Kp = 0.5; // 比例系数 5float Ki = 0.2; // 积分系数 6float Kd = 0.1; // 微分系数 7 8int error = 0; // 当前误差 9int lastError = 0; // 上一次的误差 10int integral = 0; // 误差的积分 11int derivative = 0; // 误差的微分 12 13// 红外循迹传感器定义... 14// L298N控制引脚定义... 15// 使能端引脚定义... 16// 延时函数定义... 17// Timer0 初始化函数定义... 18// 电机控制函数定义... 19 20void CalculatePID() { 21 // 根据传感器的读数计算误差，这里假设按照传感器是5个连续的数值 22 int sensorValues = (left1 \u0026lt;\u0026lt; 4) | (left2 \u0026lt;\u0026lt; 3) | (mid3 \u0026lt;\u0026lt; 2) | (right4 \u0026lt;\u0026lt; 1) | right5; 23 24 switch(sensorValues) { 25 case 0b00000: 26 case 0b11111: 27 // 特殊情况处理，比如急转弯或者丢线 28 break; 29 case 0b00100: 30 error = 0; // 小车在中心线上 31 break; 32 //...其它情况根据传感器值来设置误差值 33 } 34 35 // PID计算 36 integral = integral + error; 37 derivative = error - lastError; 38 int turn = (int)(Kp * error + Ki * integral + Kd * derivative); 39 lastError = error; 40 41 // 根据turn计算左右电机的占空比 42 Duty_left = 26 + turn; 43 Duty_right = 26 - turn; 44 45 // 确保占空比在0-100之间 46 Duty_left = Duty_left \u0026lt; 0 ? 0 : (Duty_left \u0026gt; 100 ? 100 : Duty_left); 47 Duty_right = Duty_right \u0026lt; 0 ? 0 : (Duty_right \u0026gt; 100 ? 100 : Duty_right); 48} 49 50// 中断服务函数，用于更新PWM信号 51void Timer0_Routine() interrupt 1 { 52 // 更新定时器... 53 // PWM控制代码... 54} 55 56void main() { 57 Timer0_Init(); // 定时器初始化 58 while(1) { 59 CalculatePID(); // 计算PID 60 // 控制电机... 61 } 62} ","date":"2024-05-29T01:07:19Z","image":"https://tu1.lsyblog.live/img/pid51%E5%B0%8F%E8%BD%A6.png","permalink":"https://LuoC33.github.io/p/51%E8%93%9D%E7%89%99pid%E5%BE%AA%E8%BF%B9%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%80%A5%E5%81%9C%E9%81%BF%E9%9A%9C%E5%B0%8F%E8%BD%A6/","title":"51蓝牙PID循迹超声波急停避障小车"},{"content":"{% note info simple %}在Python中，变量的类型是动态的，这意味着你不需要在声明变量时指定类型，Python会根据变量的值自动确定其类型。{% endnote %}\n数据类型 整数（int）：表示整数值，例如 1, 2, -5 等。 浮点数（float）：表示带有小数点的数值，例如 0.23, -4.56 等。 字符串（str）：表示文本数据，用单引号或双引号括起来，例如 \u0026lsquo;hello\u0026rsquo;, \u0026ldquo;world\u0026rdquo; 等。 布尔值（bool）：表示真或假，只有两个值：True 和 False。 列表（list）：表示有序的集合，可以包含不同类型的元素，用方括号括起来，例如 [1, 2, \u0026rsquo;three\u0026rsquo;, 4.0] 。 元组（tuple）：类似于列表，但是元素不能修改，用圆括号括起来，例如 (1, 2, \u0026rsquo;three\u0026rsquo;, 4.0) 。 字典（dict）：表示键值对的集合，用花括号括起来，例如 {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;Alice\u0026rsquo;, \u0026lsquo;age\u0026rsquo;: 30} 。 集合（set）：表示无序不重复元素的集合，用花括号括起来，例如 {1, 2, 3} 。 变量的定义 定义变量时，你只需要给变量赋一个值，Python会自动确定其类型： 1# 定义整数变量 2x = 10 3 4# 定义浮点数变量 5y = 3.14 6 7# 定义字符串变量 8name = \u0026#39;John\u0026#39; 9 10# 定义布尔变量 11is_true = True 12 13# 定义列表变量 14numbers = [1, 2, 3, 4, 5] 15 16# 定义元组变量 17point = (10, 20) 18 19# 定义字典变量 20person = {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 25} 21 22# 定义集合变量 23unique_numbers = {1, 2, 3, 2, 1} 在Python中，你可以使用内置函数来强制转换变量的类型：\nint(x)：将 x 转换为整数。 float(x)：将 x 转换为浮点数。 str(x)：将 x 转换为字符串。 list(x)：将 x 转换为列表（如果 x 是可迭代的）。 tuple(x)：将 x 转换为元组（如果 x 是可迭代的）。 dict(x)：将 x 转换为字典（如果 x 是键值对的迭代）。 set(x)：将 x 转换为集合（如果 x 是可迭代的）。 例如：\n1# 将浮点数转换为整数 2x = 3.99 3x_int = int(x) # x_int 的值为 3 4 5# 将整数转换为浮点数 6y = 5 7y_float = float(y) # y_float 的值为 5.0 8 9# 将整数转换为字符串 10z = 7 11z_str = str(z) # z_str 的值为 \u0026#39;7\u0026#39; 12 13# 将字符串转换为整数 14s = \u0026#39;123\u0026#39; 15s_int = int(s) # s_int 的值为 123 16 17# 将列表转换为元组 18lst = [1, 2, 3] 19lst_tuple = tuple(lst) # lst_tuple 的值为 (1, 2, 3) 20 21# 将元组转换为列表 22tpl = (4, 5, 6) 23tpl_list = list(tpl) # tpl_list 的值为 [4, 5, 6] 24 25# 将字典的键转换为集合 26dct = {\u0026#39;name\u0026#39;: \u0026#39;Bob\u0026#39;, \u0026#39;age\u0026#39;: 30} 27dct_keys_set = set(dct) # dct_keys_set 的值为 {\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;} 区别总结 可变性 ：元组是不可变的，列表和集合是可变的。 有序性 ：列表和元组是有序的，集合是无序的。 重复性 ：列表和元组可以包含重复元素，集合不允许重复元素。 操作 ：列表和集合支持添加、删除和修改元素的操作，元组不支持这些操作。 用途 ：元组常用于表示不可变的数据集合，列表用于存储有序的数据集合，集合用于存储无序且不重复的数据集合。 注意，类型转换可能会导致数据丢失或不准确，例如将浮点数转换为整数时会丢失小数部分，将字符串转换为整数时如果字符串不是有效的整数表示则会引发错误。\n{% note info simple %}在Python中，空操作（pass）是一个占位符，它不执行任何操作。pass 语句在语法上是一个完整的语句，但在功能上是一个空操作。它的主要用途是在你需要一个语句的地方提供一个占位符，但暂时不实现任何功能。{% endnote %}\n空操作的意义： 占位符：当你在编写代码时，可能需要先定义一个结构（如函数、类、循环、条件语句等），但还没有决定或实现具体的逻辑。使用 pass 可以避免语法错误，因为Python要求在这些结构中必须有语句。\n保持代码结构：在重构代码或设计API时，你可能需要先保持代码的结构完整，以便后续填充内容。\n避免编译错误：在某些情况下，如果你不提供一个语句，Python解释器会报错。pass 可以用来避免这种错误。\n空操作的运用： 1# 在函数中使用 pass 2def my_function(): 3 pass # 这里暂时没有实现任何功能 4 5# 在类中使用 pass 6class MyClass: 7 pass # 这里暂时没有定义任何方法或属性 8 9# 在条件语句中使用 pass 10if condition: 11 pass # 如果条件为真，这里暂时没有执行任何操作 12else: 13 # 其他操作 14 pass 15 16# 在循环中使用 pass 17for item in my_list: 18 pass # 这里暂时没有对每个元素执行任何操作 空操作的进阶运用： 占位符：在编写大型程序时，你可以使用 pass 来定义框架，然后逐步填充每个部分的逻辑。\n测试和调试：在调试代码时，你可以使用 pass 来临时禁用某些代码块，以便专注于其他部分的调试。\n设计模式：在某些设计模式中，如模板方法模式，你可以使用 pass 来定义抽象方法或钩子方法，这些方法在子类中被实现。\n代码文档：在编写代码文档时，你可以使用 pass 来表示某个部分是“待实现”的，这有助于其他开发者理解代码的当前状态。\n占位符变量：在某些情况下，你可能需要在代码中定义一个变量，但暂时不赋予它任何值。虽然这不是 pass 的直接用途，但你可以使用 pass 来初始化一个变量，例如 var = pass ，尽管这并不常见，也不推荐。\n总之，pass 是一个简单但非常有用的语句，它可以帮助你保持代码的结构完整性，同时允许你逐步实现代码的逻辑。\n","date":"2024-05-10T23:50:02Z","image":"https://tu1.lsyblog.live/img/py1.jpg","permalink":"https://LuoC33.github.io/p/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---%E5%8F%98%E9%87%8F%E4%B8%8E%E7%A9%BA%E6%93%8D%E4%BD%9C/","title":"python学习笔记---变量与空操作"},{"content":"{% note info simple %}Python 是一种非常注重代码格式和缩进的编程语言。在 Python 中，缩进不仅仅是美观的考量，它实际上是语法的一部分，用来定义代码块的结构。正确的缩进对于 Python 代码的运行至关重要。{% endnote %}\n判断语句（条件语句） Python 中的判断语句使用 ***if、elif（可选）和 else（可选）***关键字。下面是一个基本的判断语句的例子：\n1# 单个 if 语句 2if condition: 3 # 如果 condition 为真，执行这里的代码块 4 pass 5 6# if-else 语句 7if condition: 8 # 如果 condition 为真，执行这里的代码块 9 pass 10else: 11 # 如果 condition 为假，执行这里的代码块 12 pass 13 14# if-elif-else 语句 15if condition1: 16 # 如果 condition1 为真，执行这里的代码块 17 pass 18elif condition2: 19 # 如果 condition1 为假且 condition2 为真，执行这里的代码块 20 pass 21else: 22 # 如果所有条件都为假，执行这里的代码块 23 pass 循环语句 Python 中有两种循环语句：for循环和while循环。\nfor 循环 for循环用于遍历序列（如列表、元组、字符串等）或其他可迭代对象。\n在Python的for循环中，确实没有像C语言中那样的显式条件判断和自增/自减操作。Python的for循环是专门设计用来遍历可迭代对象（如列表、元组、字符串等）的，它会自动处理迭代过程，不需要手动设置初始条件、循环条件和更新表达式。\n1for 变量 in 可迭代对象: 2 # 循环体 在Python的for循环中，你不需要指定任何条件来控制循环的次数，因为循环次数是由可迭代对象的长度决定的。Python会自动遍历可迭代对象中的每个元素，并将当前元素赋值给循环变量，然后执行循环体。\n例如，如果你想遍历一个列表并打印每个元素，你可以这样做：\n1numbers = [1, 2, 3, 4, 5] 2for number in numbers: 3 print(number) 在这个例子中，for number in numbers: 会自动遍历列表 numbers中的每个元素，并将当前元素赋值给变量 number。循环体中的代码（即 print(number) ）会针对列表中的每个元素执行一次。\nwhile 循环 while循环在条件为真时重复执行代码块。\n1while condition: 2 # 只要 condition 为真，就执行这里的代码块 3 pass 示例 下面是一个使用 if 和 for 循环的简单示例：\n1# 遍历列表并打印每个元素 2numbers = [1, 2, 3, 4, 5] 3for number in numbers: 4 if number % 2 == 0: 5 print(f\u0026#34;{number} 是偶数\u0026#34;) 6 else: 7 print(f\u0026#34;{number} 是奇数\u0026#34;) ","date":"2024-05-10T13:38:46Z","image":"https://tu1.lsyblog.live/img/py2.jpg","permalink":"https://LuoC33.github.io/p/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF%E8%AF%AD%E6%B3%95/","title":"python学习笔记---判断循环语法"},{"content":" {% p blue, 安装虚拟机的目的 %} 虚拟机是用主机的内存和CPU开辟出的一个独立不干扰的独立空间 这里就是一个小世界，可以是Windos，linux，mac的世界，也可以是你自己的世界。 在这，我们可以测试危险的软件，可以绕过诸多检查权限的软件，不用担心被病毒感染，也不\t用担心一些软件权限过大威胁到主机，因为虚拟机和主机是完全隔离开的，虚拟机也无法读取和调用主机的权限与功能，我们只需要对虚拟机进行删除镜像，就能又一切的恢复如初。\n{% p blue, 虚拟机安装 %} 安装VMware 软件介绍：\nVMware是功能最强大的虚拟机软件，用户可以在虚拟机同时运行各种操作系统，进行开发、测试、演示和部署软件，虚拟机中复制服务器、台式机和平板环境，每个虚拟机可分配多个处理器核心、主内存和显存。\n具体安装教程\n密钥：\nVMware Workstation Pro 16 许可证密钥，批量永久激活 1ZF3R0-FHED2-M80TY-8QYGC-NPKYF 2YF390-0HF8P-M81RQ-2DXQE-M2UT6 3ZF71R-DMX85-08DQY-8YMNC-PPHV8 {% label 注意不同版本的VMware需要的密钥也不同 %}，不过这些都是可以能百度得到的密钥，无需花钱。\n{% p blue, 镜像 vmx的导入 %} 安装好后只需要{% span red, 导入你要安装的系统镜像即可 %}，例如w11，w10，linux的镜像。\n当然也可以用已经做好的vmx。 这里就不赘诉了，百度一堆教程。\n那vmx又是什么？\n我们都知道，iso是系统的镜像文件，而vmx是VMware虚拟机配置，它是虚拟机系统文件，通常通过打开这个虚拟机文件以启动系统。同样，我们通过编辑它还可以实现某种配置需求，可以用文本文档的方式将其打开。\n这里分享一些vmx\nw7精简版阿里云盘\nw7简精版天翼网盘\nw7简精版百度网盘 提取码：goxv\nw10简精版 提取码:0537\n以上资源，皆来于网络无营利性分享。\n","date":"2024-05-09T15:33:49Z","image":"https://tu1.lsyblog.live/img/虚拟机安装.jpg","permalink":"https://LuoC33.github.io/p/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85w7/w10%E4%BC%98%E5%8C%96%E7%B2%BE%E7%AE%80%E7%89%88/","title":"虚拟机安装W7/W10优化精简版"},{"content":"准备工作 下载 Tampermonkey （油猴也叫暴力猴） 将油猴下载好后加进扩展，如果你是edg，谷歌，火狐可以在插件商店一键加入，这里就不赘诉了\n我们首先确保扩展的正常启用。如图\n浏览器输入网址下载OCS网课助手 1https://cdn.ocsjs.com/ocs.user.js\t然后可以看到有个安装，因为已经安装过了，所以看到的是更新。\n安装好后就可以进入学习通看看脚本是不是已经启动了。\n但是我们要想最大程度的启动脚本，实现自动答题等功能还需要配置题库，这里也不赘述了。\n具体配置教程可以参考 官网手册\n关于U校园，welearn，批改网，以及其他的网课平台，我有时间会出教程。\n","date":"2024-05-05T20:18:12Z","image":"https://tu1.lsyblog.live/img/网课.jpg","permalink":"https://LuoC33.github.io/p/ocs%E7%BD%91%E8%AF%BE%E5%8A%A9%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%BD%91%E8%AF%BE%E8%87%AA%E5%8A%A8%E5%88%B7%E8%AF%BE/","title":"OCS网课助手实现网课自动刷课"}]