[{"content":"概述\r在C++中，对象的创建、复制、移动和销毁是由一组特殊的成员函数管理的，这些函数统称为\u0026quot;拷贝控制成员\u0026quot;。理解这些函数的工作原理对于编写安全、高效的C++代码至关重要。本文将详细讲解各种构造函数和拷贝控制成员的使用方法和区别。\n构造函数家族\r1. 默认构造函数 (Default Constructor)\r默认构造函数是在没有提供任何参数时调用的构造函数。\n1class Student { 2public: 3 // 默认构造函数 4 Student() : name(\u0026#34;未知\u0026#34;), age(0) { 5 cout \u0026lt;\u0026lt; \u0026#34;默认构造函数被调用\u0026#34; \u0026lt;\u0026lt; endl; 6 } 7 8 string name; 9 int age; 10}; 11 12// 使用示例 13Student s1; // 调用默认构造函数 14Student s2 = Student(); // 显式调用 2. 参数化构造函数 (Parameterized Constructor)\r接受参数的构造函数，用于初始化对象成员。\n1class Student { 2public: 3 // 参数化构造函数 4 Student(string n, int a) : name(n), age(a) { 5 cout \u0026lt;\u0026lt; \u0026#34;参数化构造函数被调用\u0026#34; \u0026lt;\u0026lt; endl; 6 } 7 8 string name; 9 int age; 10}; 11 12// 使用示例 13Student s1(\u0026#34;张三\u0026#34;, 20); 14Student s2 = Student(\u0026#34;李四\u0026#34;, 21); 3. 拷贝构造函数 (Copy Constructor)\r用于用一个已存在的对象初始化一个新对象。\n1class Student { 2public: 3 Student(string n, int a) : name(n), age(a) {} 4 5 // 拷贝构造函数 6 Student(const Student\u0026amp; other) 7 : name(other.name + \u0026#34;(副本)\u0026#34;), age(other.age) { 8 cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数被调用\u0026#34; \u0026lt;\u0026lt; endl; 9 } 10 11 string name; 12 int age; 13}; 14 15// 使用示例 16Student s1(\u0026#34;张三\u0026#34;, 20); 17Student s2 = s1; // 调用拷贝构造函数 18Student s3(s1); // 另一种调用方式 4. 移动构造函数 (Move Constructor)\rC++11引入，用于\u0026quot;偷取\u0026quot;临时对象的资源，提高性能。\n1class Student { 2public: 3 // 移动构造函数 4 Student(Student\u0026amp;\u0026amp; other) noexcept 5 : name(std::move(other.name)), age(other.age) { 6 other.age = 0; // 源对象置为空状态 7 cout \u0026lt;\u0026lt; \u0026#34;移动构造函数被调用\u0026#34; \u0026lt;\u0026lt; endl; 8 } 9 10 string name; 11 int age; 12}; 13 14// 使用示例 15Student createStudent() { 16 return Student(\u0026#34;临时学生\u0026#34;, 19); // 可能触发移动构造 17} 18Student s = createStudent(); // 移动构造 拷贝控制成员\r1. 拷贝赋值运算符 (Copy Assignment Operator)\r用于两个已存在对象之间的赋值操作。\n1class Student { 2public: 3 // 拷贝赋值运算符 4 Student\u0026amp; operator=(const Student\u0026amp; other) { 5 if (this != \u0026amp;other) { // 防止自赋值 6 name = other.name; 7 age = other.age; 8 cout \u0026lt;\u0026lt; \u0026#34;拷贝赋值运算符被调用\u0026#34; \u0026lt;\u0026lt; endl; 9 } 10 return *this; 11 } 12 13 string name; 14 int age; 15}; 16 17// 使用示例 18Student s1(\u0026#34;张三\u0026#34;, 20); 19Student s2(\u0026#34;李四\u0026#34;, 21); 20s2 = s1; // 调用拷贝赋值运算符 2. 移动赋值运算符 (Move Assignment Operator)\r用于给已存在对象赋值时\u0026quot;偷取\u0026quot;另一个对象的资源。\n1class Student { 2public: 3 // 移动赋值运算符 4 Student\u0026amp; operator=(Student\u0026amp;\u0026amp; other) noexcept { 5 if (this != \u0026amp;other) { 6 name = std::move(other.name); 7 age = other.age; 8 other.age = 0; // 源对象置空 9 cout \u0026lt;\u0026lt; \u0026#34;移动赋值运算符被调用\u0026#34; \u0026lt;\u0026lt; endl; 10 } 11 return *this; 12 } 13 14 string name; 15 int age; 16}; 17 18// 使用示例 19Student s1(\u0026#34;张三\u0026#34;, 20); 20Student s2(\u0026#34;李四\u0026#34;, 21); 21s2 = std::move(s1); // 移动赋值 3. 析构函数 (Destructor)\r在对象销毁时自动调用，用于清理资源。\n1class Student { 2public: 3 Student() { 4 data = new int[100]; // 动态分配内存 5 } 6 7 // 析构函数 8 ~Student() { 9 delete[] data; // 释放内存 10 cout \u0026lt;\u0026lt; \u0026#34;析构函数被调用\u0026#34; \u0026lt;\u0026lt; endl; 11 } 12 13 int* data; 14}; 15 16// 使用示例 17{ 18 Student s; // 构造函数被调用 19} // 离开作用域，析构函数被调用 关键区别与使用场景\r移动构造 vs 移动赋值\r特性 移动构造函数 移动赋值运算符 用途 创建新对象 给已有对象赋值 函数签名 Student(Student\u0026amp;\u0026amp;) operator=(Student\u0026amp;\u0026amp;) 返回值 无 Student\u0026amp; 资源清理 不需要 需要先清理自身资源 自赋值检查 不需要 需要 调用时机 创建新对象时 已有对象赋值时 移动构造函数示例：\n1// 创建新对象并\u0026#34;偷取\u0026#34;资源 2Student s2 = std::move(s1); // 移动构造 移动赋值运算符示例：\n1// 给已有对象赋值并\u0026#34;偷取\u0026#34;资源 2Student s2(\u0026#34;李四\u0026#34;, 21); 3s2 = std::move(s1); // 移动赋值 拷贝构造 vs 移动构造\r特性 拷贝构造函数 移动构造函数 参数类型 const Student\u0026amp; Student\u0026amp;\u0026amp; 资源处理 深拷贝资源 转移资源所有权 源对象状态 保持不变 被置为空状态 性能 较低（需要复制） 较高（只需转移） 完整示例类\r1class Student { 2private: 3 string name; 4 int age; 5 int* scores; // 动态数组 6 int size; 7 8public: 9 // 默认构造函数 10 Student() : name(\u0026#34;未知\u0026#34;), age(0), scores(nullptr), size(0) { 11 cout \u0026lt;\u0026lt; \u0026#34;默认构造函数\u0026#34; \u0026lt;\u0026lt; endl; 12 } 13 14 // 参数化构造函数 15 Student(string n, int a, int* s, int sz) 16 : name(n), age(a), size(sz) { 17 scores = new int[size]; 18 for (int i = 0; i \u0026lt; size; i++) scores[i] = s[i]; 19 cout \u0026lt;\u0026lt; \u0026#34;参数化构造函数\u0026#34; \u0026lt;\u0026lt; endl; 20 } 21 22 // 拷贝构造函数 23 Student(const Student\u0026amp; other) 24 : name(other.name), age(other.age), size(other.size) { 25 scores = new int[size]; 26 for (int i = 0; i \u0026lt; size; i++) scores[i] = other.scores[i]; 27 cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数\u0026#34; \u0026lt;\u0026lt; endl; 28 } 29 30 // 移动构造函数 31 Student(Student\u0026amp;\u0026amp; other) noexcept 32 : name(std::move(other.name)), age(other.age), 33 scores(other.scores), size(other.size) { 34 other.scores = nullptr; 35 other.size = 0; 36 cout \u0026lt;\u0026lt; \u0026#34;移动构造函数\u0026#34; \u0026lt;\u0026lt; endl; 37 } 38 39 // 拷贝赋值运算符 40 Student\u0026amp; operator=(const Student\u0026amp; other) { 41 if (this != \u0026amp;other) { 42 delete[] scores; 43 44 name = other.name; 45 age = other.age; 46 size = other.size; 47 scores = new int[size]; 48 for (int i = 0; i \u0026lt; size; i++) scores[i] = other.scores[i]; 49 50 cout \u0026lt;\u0026lt; \u0026#34;拷贝赋值运算符\u0026#34; \u0026lt;\u0026lt; endl; 51 } 52 return *this; 53 } 54 55 // 移动赋值运算符 56 Student\u0026amp; operator=(Student\u0026amp;\u0026amp; other) noexcept { 57 if (this != \u0026amp;other) { 58 delete[] scores; 59 60 name = std::move(other.name); 61 age = other.age; 62 scores = other.scores; 63 size = other.size; 64 65 other.scores = nullptr; 66 other.size = 0; 67 68 cout \u0026lt;\u0026lt; \u0026#34;移动赋值运算符\u0026#34; \u0026lt;\u0026lt; endl; 69 } 70 return *this; 71 } 72 73 // 析构函数 74 ~Student() { 75 delete[] scores; 76 cout \u0026lt;\u0026lt; \u0026#34;析构函数\u0026#34; \u0026lt;\u0026lt; endl; 77 } 78}; 最佳实践和建议\rRule of Three/Five：\n如果你需要自定义析构函数、拷贝构造函数或拷贝赋值运算符中的任何一个，那么很可能需要定义所有三个（Rule of Three） C++11后，还应考虑移动构造函数和移动赋值运算符（Rule of Five） 使用 = default 和 = delete：\n1class Student { 2public: 3 Student() = default; // 使用编译器生成的默认构造函数 4 Student(const Student\u0026amp;) = delete; // 禁止拷贝 5 Student(Student\u0026amp;\u0026amp;) = default; // 使用编译器生成的移动构造函数 6}; 优先使用移动语义：对于管理资源的类，实现移动操作可以显著提高性能。\n注意异常安全：移动操作通常应该标记为noexcept。\n深拷贝 vs 浅拷贝：\n浅拷贝：只复制指针，不复制指向的数据 深拷贝：复制指针和指向的数据（需要自己实现） 总结\r默认构造：创建空对象 参数化构造：带参数初始化 拷贝构造：用旧对象创建新对象 移动构造：偷取临时对象资源创建新对象 拷贝赋值：两个已存在对象之间的赋值 移动赋值：偷取临时对象资源给已存在对象赋值 析构函数：清理资源 ","date":"2025-08-31T12:34:10+08:00","image":"https://tuchuang.liushuiyu.cn/img/copy-logo20250831.webp","permalink":"https://blog.liushuiyu.cn/p/c-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/","title":"C++构造函数与拷贝控制完全指南"},{"content":"语法糖 vs connect() 实现对比详解\r1. C++信号 → QML槽函数\rC++部分 (两种连接方式共用)\r1// loginmanager.h 2class LoginManager : public QObject 3{ 4 Q_OBJECT 5public: 6 explicit LoginManager(QObject *parent = nullptr); 7 8 Q_INVOKABLE void attemptLogin(const QString \u0026amp;username, const QString \u0026amp;password); 9 10signals: 11 void loginResult(bool success, const QString \u0026amp;message); 12}; 13 14// loginmanager.cpp 实现attemptLogin 15void LoginManager::attemptLogin(const QString \u0026amp;username, const QString \u0026amp;password) 16{ 17 // 验证逻辑... 18 bool success = (username == \u0026#34;admin\u0026#34; \u0026amp;\u0026amp; password == \u0026#34;password\u0026#34;); 19 QString message = success ? \u0026#34;登录成功\u0026#34; : \u0026#34;用户名或密码错误\u0026#34;; 20 21 // 发出信号 22 emit loginResult(success, message); 23} 24 25// 注册到QML 26qmlRegisterType\u0026lt;LoginManager\u0026gt;(\u0026#34;MyApp\u0026#34;, 1, 0, \u0026#34;LoginManager\u0026#34;); QML部分 - 语法糖方式\r1import QtQuick 2.15 2import MyApp 1.0 3 4Item { 5 LoginManager { 6 id: loginManager 7 8 // 语法糖：直接使用on+信号名 9 onLoginResult: function(success, message) { 10 if (success) { 11 statusText.text = \u0026#34;欢迎回来!\u0026#34;; 12 statusText.color = \u0026#34;green\u0026#34;; 13 } else { 14 statusText.text = message; 15 statusText.color = \u0026#34;red\u0026#34;; 16 } 17 } 18 } 19 20 Button { 21 text: \u0026#34;登录\u0026#34; 22 onClicked: { 23\t//调用C++ 暴露的 Q_INVOKABLE attemptLogin 方法 24 loginManager.attemptLogin(usernameField.text, passwordField.text); 25 } 26 } 27 28 Text { 29 id: statusText 30 text: \u0026#34;请登录\u0026#34; 31 } 32} QML部分 - 显式connect方式\r1import QtQuick 2.15 2import MyApp 1.0 3 4Item { 5 LoginManager { 6 id: loginManager 7 } 8 9 // 定义处理函数 10 function handleLoginResult(success, message) { 11 if (success) { 12 statusText.text = \u0026#34;欢迎回来!\u0026#34;; 13 statusText.color = \u0026#34;green\u0026#34;; 14 } else { 15 statusText.text = message; 16 statusText.color = \u0026#34;red\u0026#34;; 17 } 18 } 19 20 // 显式连接信号和槽 21 Component.onCompleted: { 22\t//将C++的信号与qml自己定义处理函数关联 23 loginManager.loginResult.connect(handleLoginResult); 24 } 25 26 Button { 27 text: \u0026#34;登录\u0026#34; 28 onClicked: { 29 loginManager.attemptLogin(usernameField.text, passwordField.text); 30 } 31 } 32 33 Text { 34 id: statusText 35 text: \u0026#34;请登录\u0026#34; 36 } 37} 2. QML信号 → C++槽函数\rQML部分 (两种连接方式共用)\r1import QtQuick 2.15 2 3Item { 4 id: root 5 6 // 定义QML信号 7 signal userAction(string action, var data) 8 9 Button { 10 text: \u0026#34;发送数据\u0026#34; 11 onClicked: { 12 // 触发信号 13 root.userAction(\u0026#34;submit\u0026#34;, { 14 username: usernameField.text, 15 timestamp: new Date().toISOString() 16 }); 17 } 18 } 19} C++部分 - 语法糖方式\r1// datahandler.h 2class DataHandler : public QObject 3{ 4 Q_OBJECT 5 6public: 7 explicit DataHandler(QObject *parent = nullptr); 8 9 // 设置QML根对象 10 void setRootObject(QObject *root); 11 12public slots: 13 // 处理QML信号的槽函数 14 void handleUserAction(const QString \u0026amp;action, const QVariant \u0026amp;data); 15}; 16 17// datahandler.cpp 18void DataHandler::setRootObject(QObject *root) 19{ 20 if (!root) return; 21 22 // 使用QObject::connect的语法糖形式 23 // 自动连接同名信号和槽 24 QObject::connect(root, SIGNAL(userAction(QString,QVariant)), 25 this, SLOT(handleUserAction(QString,QVariant))); 26} 27 28void DataHandler::handleUserAction(const QString \u0026amp;action, const QVariant \u0026amp;data) 29{ 30 qDebug() \u0026lt;\u0026lt; \u0026#34;收到用户操作:\u0026#34; \u0026lt;\u0026lt; action; 31 if (data.canConvert\u0026lt;QVariantMap\u0026gt;()) { 32 QVariantMap dataMap = data.toMap(); 33 qDebug() \u0026lt;\u0026lt; \u0026#34;用户名:\u0026#34; \u0026lt;\u0026lt; dataMap[\u0026#34;username\u0026#34;].toString(); 34 qDebug() \u0026lt;\u0026lt; \u0026#34;时间戳:\u0026#34; \u0026lt;\u0026lt; dataMap[\u0026#34;timestamp\u0026#34;].toString(); 35 } 36} C++部分 - 显式connect方式\r1// datahandler.h 2class DataHandler : public QObject 3{ 4 Q_OBJECT 5 6public: 7 explicit DataHandler(QObject *parent = nullptr); 8 9 // 设置QML根对象 10 void setRootObject(QObject *root); 11 12public slots: 13 // 处理QML信号的槽函数 14 void handleUserAction(const QString \u0026amp;action, const QVariant \u0026amp;data); 15}; 16 17// datahandler.cpp 18void DataHandler::setRootObject(QObject *root) 19{ 20 if (!root) return; 21 22 // 显式connect方式 23 connect(root, SIGNAL(userAction(QString,QVariant)), 24 this, SLOT(handleUserAction(QString,QVariant))); 25 26 // 或使用新语法（需要函数指针转换） 27 /* 28 connect(root, \u0026amp;QObject::destroyed, this, [this](){ 29 qDebug() \u0026lt;\u0026lt; \u0026#34;QML根对象已销毁\u0026#34;; 30 }); 31 */ 32} 33 34void DataHandler::handleUserAction(const QString \u0026amp;action, const QVariant \u0026amp;data) 35{ 36 qDebug() \u0026lt;\u0026lt; \u0026#34;收到用户操作:\u0026#34; \u0026lt;\u0026lt; action; 37 if (data.canConvert\u0026lt;QVariantMap\u0026gt;()) { 38 QVariantMap dataMap = data.toMap(); 39 qDebug() \u0026lt;\u0026lt; \u0026#34;用户名:\u0026#34; \u0026lt;\u0026lt; dataMap[\u0026#34;username\u0026#34;].toString(); 40 qDebug() \u0026lt;\u0026lt; \u0026#34;时间戳:\u0026#34; \u0026lt;\u0026lt; dataMap[\u0026#34;timestamp\u0026#34;].toString(); 41 } 42} 实现细节对比\r语法糖方式\rC++信号 → QML槽:\nQML引擎在解析QML文件时识别onXxx属性 自动生成JavaScript函数作为槽 在对象创建完成后立即建立连接 无需手动编写connect代码 QML信号 → C++槽:\n在C++中使用旧式SIGNAL/SLOT宏语法 自动处理参数类型转换 比显式connect更简洁，但编译时检查更弱 显式connect方式\rC++信号 → QML槽:\n需要单独定义处理函数 在Component.onCompleted中手动连接 可以在任何时候连接/断开 更灵活，但代码更冗长 QML信号 → C++槽:\n使用标准connect函数 需要明确指定信号和槽 可以使用新式语法（函数指针）或旧式语法（宏） 编译时类型检查更强（新式语法） 性能和使用场景分析\r语法糖优势\r代码更简洁直观 QML引擎可能进行优化（内部实现更高效） 适合固定的、永久的连接 减少错误可能性（不会拼写错误connect参数） 显式connect优势\r动态控制连接生命周期 条件性连接（根据条件决定是否连接） 多个处理器（一个信号可以连接到多个不同函数） 信号转发（可以连接信号到信号） 1// 显式connect的灵活性示例 2Component.onCompleted: { 3 if (settings.debugMode) { 4 dataSource.dataChanged.connect(logDataChange); 5 } 6 7 if (settings.notificationsEnabled) { 8 dataSource.dataChanged.connect(showNotification); 9 } 10 11 // 信号转发 12 dataSource.dataChanged.connect(root.onDataUpdated); 13} 14 15// 动态断开连接 16function disableLogging() { 17 dataSource.dataChanged.disconnect(logDataChange); 18} 总结\r语法糖本质上就是简化版的connect，底层实现相似 两种方式性能差异不大，主要区别在于灵活性和代码简洁性 简单固定连接用语法糖，复杂动态连接用显式connect 不论哪种方式，C++和QML的交互都需要通过Qt元对象系统和JS引擎桥接 ","date":"2025-08-30T20:26:16+08:00","image":"https://tuchuang.liushuiyu.cn/img/c-qml-logo20250830.webp","permalink":"https://blog.liushuiyu.cn/p/%E8%AF%AD%E6%B3%95%E7%B3%96-vs-connect-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94%E8%AF%A6%E8%A7%A3/","title":"语法糖 vs connect() 实现对比详解"},{"content":"gitignore 的作用\r用于告诉 Git 哪些文件或文件夹不需要纳入版本控制，比如：\n临时文件（如 *.tmp） 编译产物（如 *.exe） IDE 配置文件（如 .idea/） 敏感信息（如 passwords.txt） 文件放置位置\r项目根目录：/项目路径/.gitignore（对当前仓库生效） 全局配置：~/.gitignore_global（对所有仓库生效，需运行 git config \u0026ndash;global core.excludesfile ~/.gitignore_global） 基础语法规则\r忽略单个文件\r1debug.log 忽略特定文件夹\r1# 忽略所有目录下的 .idea 文件夹 2**/.idea/ 通配符匹配\r通配符 示例 作用 * *.tmp 忽略所有.tmp文件 ? ?.log 忽略单字符命名的日志（如a.log） ** **/build/ 递归忽略所有层级的build文件夹 排除例外（不忽略）\r1# 忽略所有 .txt 文件，但不忽略 important.txt 2*.txt 3!important.txt 高级技巧\r强制添加被忽略的文件\r1git add -f secret_file.txt # 即使被忽略也会强制添加 检查忽略规则是否生效\r1git check-ignore -v path/to/file # 查看具体哪条规则忽略了该文件 清理已提交的忽略文件\r如果之前误提交了需要忽略的文件：\n1git rm --cached .idea/ # 从 Git 中删除但保留本地文件 2git commit -m \u0026#34;Remove .idea from Git\u0026#34; 常见问题解答\rQ1：为什么 .gitignore 不生效？\r文件已提交过：需先运行 git rm \u0026ndash;cached 路径错误：确保 .gitignore 在项目根目录 语法错误：避免使用中文符号或多余空格 Q2：如何忽略所有文件夹下的特定文件？\r1# 忽略所有目录下的 .DS_Store 文件 2**/.DS_Store Q3：如何忽略除指定文件外的所有同类文件？\r1# 忽略所有 .log 文件，但保留 error.log 2*.log 3!error.log .gitignore 规则速查表\r需求 写法 示例 忽略特定文件夹 folder/ build/（忽略build文件夹） 忽略所有目录下的同名文件夹 **/folder/ **/tmp/（忽略所有tmp文件夹） 忽略特定文件 file.ext config.ini（忽略该文件） 忽略某类扩展名的文件 *.ext *.log（忽略所有.log文件） 忽略任意层级的某类文件 **/*.ext **/*.tmp（忽略所有.tmp文件） 忽略系统文件（如.DS_Store） .DS_Store （Mac 的临时文件） 不忽略某个文件（例外） !file.ext !important.txt（不忽略该文件） 忽略空文件夹（占位） folder/+ 放.gitkeep （Git 默认不跟踪空文件夹） 注释（说明） # 注释内容 # 忽略所有临时文件 常用场景示例\r忽略 build/ 和 node_modules/** 1 build/ 2 node_modules/ 忽略所有 .log 和 .tmp，但保留 important.log 1 *.log 2 *.tmp 3 !important.log 忽略所有 IDE 配置文件（如 JetBrains） 1 **/.idea/ 2 **/*.iml 注意事项\r✅ 路径问题\n/folder/ 仅忽略根目录下的 folder folder/ 忽略所有 folder 目录 **/folder/ 匹配任意层级的 folder ❌ 常见错误\n误用 folder（不带 /，可能匹配文件）\n规则顺序错误（如 !important.txt 必须放在 *.txt 之后）\n已提交的文件需先删除缓存：\n1 git rm --cached \u0026lt;file\u0026gt; 这样写 .gitignore 就清晰多了！ 🚀\n","date":"2025-06-23T15:41:25+08:00","image":"https://tuchuang.liushuiyu.cn/img/git-management20250830.webp","permalink":"https://blog.liushuiyu.cn/p/gitignore%E7%AC%94%E8%AE%B0/","title":"gitignore笔记"},{"content":"Usart通信简易原理图\rGND 供地是为了平衡电压基准，使得双方共用一套电压标准，用于评判高低电压。 Tx ：发送数据 Rx：接收数据 数据的串并转换\rSTM32 的串并转化寄存器\r​\n寄存器 TDR 实现将并行数据转换为串行数据。 寄存器 RDR 实现串行数据转换为并行数据。 串并数据的详细解释\r​\n串行数据是指数据以一个接一个的方式在时间上连续传输，也就是说，数据位是按顺序逐个发送的。这种方式通常用于长距离传输，因为它可以减少所需的线缆数量。 并行数据则是指数据的多个位在同一时刻通过多条通道同时传输，这种方式在短距离传输中效率较高，但由于受限于线路数量和信号干扰，通常不适合长距离通信。 STM32_Usart 模块完整示意图\r​\n状态寄存器(SR)\rSR 寄存器用于指示 USART 的当前状态，包括是否有数据可接收、发送缓冲区是否为空等。\n重要位：\nRXNE（Receive Data Register Not Empty）：接收数据寄存器(RDR)非空，表示有数据接收。 TXE（Transmit Data Register Empty）：发送数据寄存器(TDR)为空，表示可以发送数据。 TC（Transmit Complete）：发送完成 TDR空\u0026amp;\u0026amp;移位寄存器空。 ORE（Overrun Error）：接收溢出错误，表示接收的数据被覆盖。 FE（Framing Error）：帧错误，表示接收到的帧不正确。 PE（Parity Error）：奇偶校验错误标志位 NE（Noise Error）：噪声错误标志位 配置寄存器(CR)\r序号 名称 描述 0 UE (USART Enable) 启用 USART 外设，必须设置此位才能开始通信。 1 TE (Transmitter Enable) 启用发送器，允许数据发送。 2 RE (Receiver Enable) 启用接收器，允许数据接收。 3 R/W (Receiver/Transmit) 设置为 1 时，选择到接收模式，设置为 0 时，选择到发送模式。 4 M (Word Length) 数据位长度（0=8 位，1=9 位）。 5 WAKE (Wake-up method) 唤醒选择（0=普通模式，1=地址模式）。 6 PCE (Parity Control) 奇偶校验使能（0=禁用，1=启用）。 7 PS (Parity Selection) 奇偶校验选择（0=偶校验，1=奇校验）。 8 PEIE (PE Interrupt Enable) 奇偶校验错误中断使能。 9 TXEIE (TX Interrupt Enable) 发送数据寄存器空中断使能。 10 RXNEIE (RX Interrupt Enable) 接收数据寄存器非空中断使能。 11 TEIE (Transmission Error Interrupt Enable) 发送错误中断使能。 12 LBDIE (LIN Break Detection Interrupt Enable) LIN 中断使能。 13 CTSIE (CTS Interrupt Enable) 清除发送中断使能。 14 CBM (Character Match) 字符匹配模式（用在 LIN 模式下）。 15 OVER8 (Oversampling) 过采样模式选择（0=16 倍过采样，1=8 倍过采样）。 ​\nCR 寄存器主要用于数据帧的配置，数据帧通常由起始位(1 bit)+ 数据位(8~9 bit)+ 停止位(0.5、1、1.5、2 bit)构成。\nM - 数据位长度\nPCE - 奇偶校验使能\nPS - 奇偶选择\nSTOP - 停止位长度\nSTOP: 00 ~ 1 位 STOP: 01 ~ 0.5 位 STOP: 10 ~ 2 位 STOP: 11 ~ 1.5 位 TEX - 发送开关\nREX - 接收开关\nUE - Usart 使能\nUE: 0 Usart 禁止 UE: 1 Usart 使能 波特率寄存器(BRR)\r波特率的定义\r波特率：每秒传输码元的个数\nBRR 寄存器位数解释\r​\n双缓冲与连续发送\r双缓冲与连续发送概述\r双缓冲：\n在 USART 中，双缓冲通常指的是使用两个缓冲区来存储待发送的数据。这样，当一个缓冲区正在发送数据时，另一个缓冲区可以准备下一个发送数据，确保数据的连续性。 例如，一个缓冲区用于存放正在发送的数据，另一个缓冲区用于接收新的数据，避免因发送延迟而导致数据丢失。 连续发送：\n连续发送是指在没有人为的干预下，USART 能够不断地从缓冲区中读取数据进行发送。这意味着能够在短时间内快速发送多个数据字节，特别适合于需要实时传输大量数据的应用。 在 STM32F103 中，利用 USART 的发送中断和 DMA（直接内存访问）可以实现高效的连续发送。 STM32F103 双缓冲技术实现\r发送和接收过程中都有着两个缓冲区，第一缓冲区：TDR/RDR 第二缓冲区：移位寄存器\n第一层发送缓冲：通过判断 TXE 标志位（TXE=1,TDR 为空，TXE=0，TDR 不为空）来决定是否将数据写入到 TDR 寄存器当中。 第二层发送缓冲：TDR 将数据写入到移位寄存器中，移位寄存器进行串并转换。 第一层接收缓冲：通过判断 RXEN 标志位（RXEN=1,RDR 不为空，RXEN=0，RDR 不为空）来决定是否将数据写入到移位寄存器当中。 第二层发送缓冲：移位寄存器实现串并转换将数据写入到RDR寄存器当中 。 1//基于寄存器开发的伪代码 2 3//数据的单个发送 4while(TXE:= 0);//等待TDR寄存器为空 5TDR: data; //将数据写入TDR寄存器当中 6while(TC==0);//等待全部数据发送完毕 7//数据的连续发送 8for(int i=0;i\u0026lt;n;i++) 9{ 10\twhile(TXE:= 0); 11\tTDR: data; 12} 13while(TC==0); 14 15//数据的接收 16while(RXEN:= 0);//当接收移位寄存器没有数据时，代表数据已经完整写入RDR中 17a: RDR; //通过变量读取RDR寄存器中的数据 18//连续接收多个数据 19int arr[MAXSIZE]; 20for(int i=0;i\u0026lt;MAXSIZE;i++) 21{ 22\twhile(RXEN:= 0);//当接收移位寄存器没有数据时，代表数据已经完整写入RDR中 23\tarr[i]: RDR; //通过变量读取RDR寄存器中的数据 24} STM32标准库Usart的编程实现\r基础5大接口\r1void USART_Init(…);// 初始化(帧格式、波特率) 2void USART_Cmd(…);// 总开关 3void USART_SendData(…);//写TDR寄存器 4uint16_t USART_ReceiveData(…);//读RDR寄存器 5FlagStatus USART_GetFlagStatus(…);// 读标志位 USART_Init接口\r1// @简介：串口初始化 2// @参数：USARTx-选择要操作的串口，可以是USART1,USART2,USART3,UART4或USART5 3// @参数：USART_InitStruct-初始化参数，USART_IinitTypeDef结构体指针类型 4typedef struct USART_InitTypeDef 5{ 6 uint32_t USART_BaudRate; /*!\u0026lt; 此成员配置 USART 通信的波特率。*/ 7 8 uint16_t USART_WordLength; /*!\u0026lt; 指定在帧中传输或接收的数据位数。 9 此参数可以是 @ref USART_Word_Length 的一个值 */ 10 11 uint16_t USART_StopBits; /*!\u0026lt; 指定传输的停止位数。 12 此参数可以是 @ref USART_Stop_Bits 的一个值 */ 13 14 uint16_t USART_Parity; /*!\u0026lt; 指定奇偶校验模式。 15 此参数可以是 @ref USART_Parity 的一个值。 16 @note 当启用奇偶校验时，计算出的奇偶校验位会插入到传输数据的最高有效位（当字\t长设置为 9 位数据时为第 9 位；当字长设置为 8 位数据时为第 8 位）。 */ 17 18 uint16_t USART_Mode; /*!\u0026lt; 指定接收或发送模式是否启用或禁用。 19 此参数可以是 @ref USART_Mode 的一个值 */ 20 21 uint16_t USART_HardwareFlowControl; /*!\u0026lt; 指定硬件流控制模式是否启用或禁用。 22 此参数可以是 @ref USART_Hardware_Flow_Control 的一个值 */ 23}USART_InitTypeDef; 24 25void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct); 26 27USART_InitTypeDef USARTInitStruct;//创建结构体变量 28 29//为变量结构体成员赋值 30USARTInitStruct.USART_WordLength= xxx; 31USARTInitStruct.USART_Parity=xxx; 32USARTInitStruct.USART_StopBits=xxx; 33USARTInitStruct.USART_Mode=xxx; 34USARTInitStruct.USART_BaudRate=xxx; /*!\u0026lt; 此成员配置 USART 通信的波特率。*/ 35USARTInitStruct.USART_HardwareFlowControl=xxx; 36 37USART_Init(USARTx,\u0026amp;USARTInitStruct);//调用Init接口 USART_Cmd接口\r1// @简介：控制USART总开关的断开和闭合 2// @参数：USARTx-选择要操作的串口，可以是USART1,USART2,USART3,UART4或USART5 3// @参数：NewState-开关状态，ENABLE -闭合，DISABLE -断开 4void USART_Cmd(USART_TypeDef* USARTx, FunctionalStateNewState); 5 6USART_Cmd(USART1, ENABLE); // 闭合USART1开关 7USART_Cmd(USART1, DISABLE); // 断开USART1开关 USART_SendData接口\r1// @简介：向TDR写数据 2// @参数：USARTx-选择要操作的串口，可以是USART1,USART2,USART3,UART4或USART5 3// @参数：Data -要写入的数据 4void USART_SendData(USART_TypeDef* USARTx, uint16_t Data); 5 6USART_SendData(USART1, 0x5a); // 发送0x5a USART_ReceiveData接口\r1// @简介：从RDR读取数据 2// @参数：USARTx-选择要操作的串口，可以是USART1,USART2,USART3,UART4或USART5 3// @返回值：读取到的数据 4uint16_t USART_ReceiveData(USART_TypeDef* USARTx); 5 6uint8_t a: USART_ReceiveData(USART1); USART_GetFlagStatus接口\r1// @简介：向TDR写数据 2// @参数：USARTx-选择要操作的串口，可以是USART1,USART2,USART3,UART4或USART5 3// @参数：USART_Flag-标志位名称。 4//可以是USART_FLAG_TXE，USART_FLAG_RXNE，USART_FLAG_ORE，USART_FLAG_TC，USART_FLAG_PE， 5//USART_FLAG_PE，USART_FLAG_FE，USART_FLAG_NE 6// @返回值：标志位状态，SET -1， RESET -0 7FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_Flag); 8while(USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET); 9while(USART_GetFlagStatus(USART1,USART_FLAG_RXNE)==RESET); 10if(USART_GetFlagStatus(USART1,USART_FLAG_PE)==SET){} ","date":"2025-01-06T22:34:07+08:00","image":"https://tuchuang.liushuiyu.cn/img/Usart_post_cover.webp","permalink":"https://blog.liushuiyu.cn/p/%E9%82%A3%E6%97%B6%E6%88%91%E4%BB%AC%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B8%E9%81%87usart-1/","title":"那时我们第一次相遇：USART 1"},{"content":"GPIO输出输入的简单原理\r输出：通过寄存器写0或者是1，控制引脚输出低电压或者是高电压。\n输入：通过读取引脚的寄存器是0还是1，判断是高电压还是低电压。\nGPIO的四种输出模式\r推挽与开漏\r推挽输出\r推挽输出是GPIO（通用输入输出）的一种输出配置，能够驱动电平高或低。\n实现原理：STM32中的推挽输出配置由一个PMOS和一个NMOS组成：\nPMOS：连接到VDD，导通时输出高电平。\nNMOS：连接到GND，导通时输出低电平。\n应用：用于需要驱动电流的场合，如驱动LED、继电器等。\n开漏输出\r开漏输出仅能拉低电平，不能主动拉高，需要通过外部上拉电阻将电平拉高到逻辑高\n实现原理：开漏配置只有一个NMOS连接到GND：\n当NMOS导通时，输出低电平。\n需要外部上拉电阻将电平拉高。\n应用：适合I2C总线等需要多个设备连接的场合。\n复用推挽与复用开漏\r通用模式，是由CPU通过寄存器输出控制IO的高低电压。但实际开发功能需求中许多功能是需要一个源源不断的信号作为通信、工作的基础，那么直接通过CPU模拟工作就显得不足。\n故此，引入了复用模式，如图所见，直接将控制权交给片上外设，由他们直接来输出信号。\n采用复用模式通过硬件外设实现功能，效率高，不容易出错。避免了CPU模拟持续监控和控制引脚的缺点。在时序精度和稳定性上表现的都更加的出色。\n而且硬件外设可以处理复杂协议，如I2C，SPI，UART等，而软件模拟实现复杂协议较为困难。且硬件外设通常设计为低功耗，而软件模拟需要CPU持续工作，功耗更高。\n复用推挽\r电平输出：\n高电平时：PMOS导通，输出VDD。\n低电平时：NMOS导通，输出GND。\n特性：\n能源驱动：允许双向电流流动，适合高驱动应用。\n输出速度快，适合需要快速切换的信号。\n复用开漏\r电平输出：\n低电平时：NMOS导通，连接GND。\n高电平时：NMOS关断，依靠外部上拉电阻提供高电平。\n特性：\n线与功能：多个设备可连接同一条线上，实现多设备通信（如I2C）。\n对外部干扰敏感度低。\nGPIO的四种输入模式\r输入上拉和输入下拉\r如图所示，输入上拉即Vdd接通通过上拉电阻，因为施密特触发器输入阻抗无穷大，可等效为一个无穷大电阻,输入上拉和输入下拉是指当引脚处于浮空状态时，通过上拉电阻和下拉电阻来 确定电压，避免外界噪声干扰。\n输入浮空\r顾名思义，即不采用上拉电阻，也不采用下拉电阻，这时候易受到外界噪声干扰，产生浮动。\n模拟输入\r我们有时候需要用AD采集到IO口上面的真实电压。这就有了我们所需要的模拟输入。为了让外部的电压真实的读取到单片机的AD模块，我们既不能闭合上拉和下拉的开关，也不能让信号经过施密特触发器进行滤波。\n","date":"2024-10-02T00:00:00Z","image":"https://tuchuang.liushuiyu.cn/img/%E5%8D%95%E7%89%87%E6%9C%BA.jpg","permalink":"https://blog.liushuiyu.cn/p/stm32-io%E8%BE%93%E5%87%BA%E4%B8%8E%E8%BE%93%E5%85%A5%E4%B8%80/","title":"STM32-IO输出与输入（一）"},{"content":"第一颗樱桃：单恋 作者：南雪\n17岁，我上高中。爱上了一个男生。我没告诉他。高考，那个男生落了榜，卖掉了高中参考书，要远走西藏。那天，我到学校拿录取通知书，在校门口见他守在一大堆书前，身边一个穿蓝衣的老头儿，用秤称一沓沓书的重量。那一天，他卖掉的书中，有一本崭新的、从未翻阅过的《朱自清散文选》。在老头儿那里，我将书买了回来，花2元钱，原书的十分之一的价钱。回家，翻到了第20页，那儿写着小小的一行字：我喜欢你。清楚的四个字，他没有看到。他是不喜欢朱自清的人。那本书，是我送给他的，那行字是我写的。 很久很久以后，我知道，在一个不爱的人眼中，单恋的价格如同打哈欠时流出的眼泪，廉价，刚开始时是19块8，后来是2块。\n","date":"2024-09-30T10:22:55Z","image":"https://tuchuang.liushuiyu.cn/img/%E5%8D%95%E6%81%8B.webp","permalink":"https://blog.liushuiyu.cn/p/%E7%AC%AC%E4%B8%80%E9%A2%97%E6%A8%B1%E6%A1%83%E5%8D%95%E6%81%8B/","title":"《第一颗樱桃：单恋》"},{"content":"了解工具链\r明白什么是工具链\r工具链，官方来说，是指用于将源代码转换为可执行程序的一系列工具的集合。通俗地理解，就是开发过程中使用的工具集合。一般情况下，工具链主要指狭义的部分，包括编译器（如GCC、G++）、构建工具以及开发环境（如IDE：VSCode、CLion等）。开发系统（如Windows、Linux、MacOS）也可以视为支撑工具链的一部分。\n这么说能理解吗？就好比你要吃饭，得先要用水洗米，然后装水后再用电饭锅煮米对吧？在这个过程中，你用到的水、电、电饭锅都是工具链中的一环。\n为什么要来了解工具链\r对于入门菜鸟来说，他所学的，他所看到的，未必是全面和绝对正确的，纵观各大教程，很少人会真正的去引导一个刚刚入门计算机、刚学习编程的小白菜鸟。\n工具链的理解我认为是新手必不可少的一部分，如下面代码：\n1//只有Gcc工具链的编译器才能执行 2#include \u0026lt;stdio.h\u0026gt; 3 4int main() { 5 int n; 6 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 8 // 可变长数组 9 int arr[n]; 10 11 // 初始化数组 12 for (int i: 0; i \u0026lt; n; i++) { 13 arr[i]: i * i; 14 } 15 16 // 打印数组 17 printf(\u0026#34;Array elements are:\\n\u0026#34;); 18 for (int i: 0; i \u0026lt; n; i++) { 19 printf(\u0026#34;%d \u0026#34;, arr[i]); 20 } 21 22 printf(\u0026#34;\\n\u0026#34;); 23 24 return 0; 25} 可以拿这段代码去各个IDE跑一跑，你就会发现，有的IDE会报错，而有的IDE就能过。\n这其实就是工具链不同而导致的一些小差异，反正在我初学C语言的时候，就去网上找到一些有意思的代码，复制下来直接跑（如烟花大爆炸、 代码雨）但是很多时候都会遇上一路报红。\n这其实不是代码有问题，也不是你的电脑有问题，而是单纯的你们开发环境不一致导致的。\n更加离谱的是下面的 代码：\n1 2#include \u0026lt;stdio.h\u0026gt; 3 4int main(void) { 5 long double arr[100]; 6 scanf(\u0026#34;%lf\u0026#34;,\u0026amp;arr); 7 printf(\u0026#34;%lf\u0026#34;,arr); 8 return 0; 9} 你会发现这段代码，在VScode和DevC++上跑出来的结果始终为0.000,其实原因就是因为他们用的工具链是GCC，如果你用的是VS，那就能跑出正确的结果，因为VS用的是MSVC。\n你可能在看教学视频的时候，用的不是和博主同一个ide来写代码，这时候如果你去复现他的代码，可能就会出现我刚才举的这两个例子。\n你复现不出来，你会百思不得其解，其实是你一开始你就已经抛空了你学习的地基，你都不知道C语言能够被编译执行的流程和原理，你就会学得迷迷糊糊，或许你是练武天才，这种倒逆行施下没走火入魔也可以说是 韧性不错。\n","date":"2024-09-26T22:45:35+08:00","image":"https://tuchuang.liushuiyu.cn/img/C%E8%AF%AD%E8%A8%80%E5%B7%A5%E5%85%B7%E9%93%BE.png","permalink":"https://blog.liushuiyu.cn/p/c%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8--%E5%B7%A5%E5%85%B7%E9%93%BE/","title":"C语言入门--工具链"},{"content":"实现功能：\r能够实现自动识别黑线，完成5路循迹。 能够通过蓝牙于89C52系列芯片串口通信控制小车 能够自动感应障碍物实现自动刹停。 准备材料：\r89C52芯片及最小系统板 ， L298n模块， 模拟量5路循迹模块, 稳压模块， HC-06模块， 超声波模块， 亚巧克力板， 4个电机， 12vDC电源， DC转接母头 普通小车使能实现原理：\r利用51单片机IO口控制L298n模块引脚供电实现对电机触发。再通过EN使能端进行PWM调速，实现转弯，漂移，转圈等特殊转速。\nIN为L298N模块控制引脚\nEN为L298N模块使能引脚\nL298N模块单边IN为0,0时，电机停止转动，为1,0 、0,1时正转、反转\n1#include \u0026lt;REGX52.H\u0026gt; 2unsigned char Duty_left,Duty_right,j=0,i=0; 3//l298n 4sbit IN11=P0^2;//左前轮 5sbit IN12=P0^1; 6 7sbit IN13=P0^3;//右前轮 8sbit IN14=P0^4; 9 10sbit IN21=P1^1;//左后轮 11sbit IN22=P1^2; 12 13sbit IN23=P1^4;//右后轮 14sbit IN24=P1^3; 15 16//使能端 17sbit EN1A=P0^0;//左前 18sbit EN1B=P0^5;//右前1 19sbit EN2A=P1^6;//左后 20sbit EN2B=P1^7;//右后1 21 22 //定时器+中断 23void Timer0_Init()\t//100微秒@11.0592MHz 24{ 25 TMOD|=0x01;//定时器T0，，工作方式都为方式1 26 TH0=0xff;//定时ff9c0.1ms fe0c0.5ms 27 TL0=0x9c; 28 29 EA=1; //开启总中断 30 ET0=1;//开启中断允许 31 TR0=1;//开启定时器中断 32} 33//利用中断，PWM调速 34void Timer0_Routine() interrupt 1 35{ 36 TH0=0xff;//定时ff9c0.1ms fe0c0.5ms 37 TL0=0x9c; 38\t39 i++; 40 j++; 41 42if(i\u0026lt;=Duty_left) 43\t{ 44\tEN1A=1; 45\tEN2A=1; 46\t} 47else 48\t{ 49\tEN1A=0; 50\tEN2A=0; 51\t} 52if(j\u0026lt;=Duty_right) 53\t{ 54\tEN1B=1; 55\tEN2B=1; 56\t} 57else 58\t{ 59\tEN1B=0; 60\tEN2B=0; 61\t} 62\t63\tif(i==100) //设置pwm周期=0.1ms*100=10ms,这样开头定义的变量正好表示占空比数值 64 { 65 i=0;//加到100后变为0，重新计数 66 } 67 if(j==100) //设置pwm周期=0.1ms*100=10ms,这样开头定义的变量正好表示占空比数值 68 { 69 j=0; 70 } 71 72} 蓝牙小车原理：\r通过将蓝牙模块的{% label TX %}与{% label RX %}与单片机交叉相接进行串口通信，实现收发数据。\n1#include \u0026lt;REGX52.H\u0026gt; 2//l298n 3sbit IN11=P0^2;//左前轮 4sbit IN12=P0^1; 5 6sbit IN13=P0^3;//右前轮 7sbit IN14=P0^4; 8 9sbit IN21=P1^1;//左后轮 10sbit IN22=P1^2; 11 12sbit IN23=P1^4;//右后轮 13sbit IN24=P1^3; 14 15char i; 16unsigned char ReceiveData; //接收到的数据存放变量 17//向左转 18void correct_left() 19{ 20 IN11=0; 21 IN12=0; 22\tIN21=0; 23 IN22=0; 24\t25 IN13=1; 26 IN14=0; 27\tIN23=1; 28 IN24=0; 29 30 31} 32//向右转 33void correct_right() 34{ 35 IN11=1; 36 IN12=0; 37\tIN21=1; 38 IN22=0; 39\t40 IN13=0; 41 IN14=0; 42\tIN23=0; 43 IN24=0; 44 45 46} 47 48//左转 49void Left_turning() 50{ 51 52 IN11=0; 53 IN12=1; 54 IN21=0; 55 IN22=1; 56\t57 IN13=1; 58 IN14=0; 59 IN23=1; 60 IN24=0; 61} 62//右转 63void Right_turning() 64{ 65 66 IN11=1; 67 IN12=0; 68 IN21=1; 69 IN22=0; 70\t71 IN13=0; 72 IN14=1; 73 IN23=0; 74 IN24=1; 75} 76//小车直走前行，不拐弯速度赋值 77void forward_move() 78{ 79 80 IN11=1; 81 IN12=0; 82 IN21=1; 83 IN22=0; 84\t85 IN13=1; 86 IN14=0; 87 IN23=1; 88 IN24=0; 89} 90 91void back() 92{ 93 94 IN11=0; 95 IN12=1; 96 IN21=0; 97 IN22=1; 98\t99 IN13=0; 100 IN14=1; 101 IN23=0; 102 IN24=1; 103} 104 105void stop() 106{ 107 108 IN11=0; 109 IN12=0; 110 IN21=0; 111 IN22=0; 112\t113 IN13=0; 114 IN14=0; 115 IN23=0; 116 IN24=0; 117} 118 119 120 121void receive(unsigned char m)//执行函数 122{ 123\tswitch(m) 124\t{ 125\tcase \u0026#39;8\u0026#39;:forward_move();break; 126\tcase \u0026#39;5\u0026#39;:stop();break;//停止 127\t} 128} 129 130void Uart_Init()\t//9600bps@11.0592MHz 131{ 132\tPCON = 0x00;\t//波特率不倍速s 133\tSCON = 0x50;\t//8位数据,可变波特率 134\tTMOD = 0x20;\t//设定定时器1为8位自动重装方式 135\tTL1 = 0xFD;\t//设定定时初值 136\tTH1 = 0xFD;\t//设定定时器重装值 137\tET1 = 0;\t//禁止定时器1中断 138\tTR1 = 1;\t//启动定时器1 139\tEA=1; //总中断 140\tES=1; //打开串口中断 141} 142 143void Uart_Routine() interrupt 4 //中断 144{ 145 stop(); 146 RI=0; //清除接收中断标志位 147 ReceiveData=SBUF; //除去接受的数据 148\treceive(ReceiveData); 149} 150 151void main() 152{ 153\tUart_Init(); 154\twhile(1); 155} 超声波急停避障小车原理：\r1.采用 IO 口 {% label TRIG %} 触发测距，给一个 10us 的高电平信号；\n2.模块自动发送 8 个 40khz 的方波，自动检测是否有信号返回；\n3.有信号返回，通过 IO 口 {% label ECHO %} 输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间。\n4.测试距离=（高电平时间*声速（340M/S））/2\n{% image https://img2.imgtp.com/2024/05/29/C0lSwYoH.png, alt= %}\n1#include \u0026lt;REGX52.H\u0026gt; 2#include \u0026#34;delay.h\u0026#34; 3sbit Trig=P3^3;//定义超声波模块引脚 4sbit Echo=P3^2; 5unsigned int a,distance; 6 7int csb() 8{\t9 10\t11\tTMOD \u0026amp;= 0x0F;\t//设置定时器模式 12\t13\tTL1 = 0;\t//设置定时初始值 14\tTH1 = 0;\t//设置定时初始值 15\t16\t17\tTrig=1;//发射20US的脉冲 18 Delay10us(2); 19 Trig=0;//关闭 20\t21\t22 while(!Echo);//等待返回脉冲 23 TR1=1; 24 while(!Echo);//返回脉冲结束 25 TR1=0; 26\t27 a=TH1*256+TL1; 28 TH1=0; 29 TL1=0; 30\t31 distance= a*1.7/100; //计算公式，按照数据手册为准，不同环境不同计算方法。 32\t33\tTrig=0; 34\tEcho=0; 35\treturn distance; 36} 37 5路PID循迹小车原理：\r{% image https://img2.imgtp.com/2024/05/29/jT3cO80Q.png, alt= %}\n简单的循迹就是通过循迹模块反馈给单片机的高低电平信号进行不断判断和迭代，列出全部情况，这里就不做赘述。在此分享和学习关于PID算法循迹。\n1#include \u0026lt;REGX52.H\u0026gt; 2 3// 定义PID控制的参数 4float Kp = 0.5; // 比例系数 5float Ki = 0.2; // 积分系数 6float Kd = 0.1; // 微分系数 7 8int error = 0; // 当前误差 9int lastError = 0; // 上一次的误差 10int integral = 0; // 误差的积分 11int derivative = 0; // 误差的微分 12 13// 红外循迹传感器定义... 14// L298N控制引脚定义... 15// 使能端引脚定义... 16// 延时函数定义... 17// Timer0 初始化函数定义... 18// 电机控制函数定义... 19 20void CalculatePID() { 21 // 根据传感器的读数计算误差，这里假设按照传感器是5个连续的数值 22 int sensorValues = (left1 \u0026lt;\u0026lt; 4) | (left2 \u0026lt;\u0026lt; 3) | (mid3 \u0026lt;\u0026lt; 2) | (right4 \u0026lt;\u0026lt; 1) | right5; 23 24 switch(sensorValues) { 25 case 0b00000: 26 case 0b11111: 27 // 特殊情况处理，比如急转弯或者丢线 28 break; 29 case 0b00100: 30 error = 0; // 小车在中心线上 31 break; 32 //...其它情况根据传感器值来设置误差值 33 } 34 35 // PID计算 36 integral = integral + error; 37 derivative = error - lastError; 38 int turn = (int)(Kp * error + Ki * integral + Kd * derivative); 39 lastError = error; 40 41 // 根据turn计算左右电机的占空比 42 Duty_left = 26 + turn; 43 Duty_right = 26 - turn; 44 45 // 确保占空比在0-100之间 46 Duty_left = Duty_left \u0026lt; 0 ? 0 : (Duty_left \u0026gt; 100 ? 100 : Duty_left); 47 Duty_right = Duty_right \u0026lt; 0 ? 0 : (Duty_right \u0026gt; 100 ? 100 : Duty_right); 48} 49 50// 中断服务函数，用于更新PWM信号 51void Timer0_Routine() interrupt 1 { 52 // 更新定时器... 53 // PWM控制代码... 54} 55 56void main() { 57 Timer0_Init(); // 定时器初始化 58 while(1) { 59 CalculatePID(); // 计算PID 60 // 控制电机... 61 } 62} ","date":"2024-05-29T01:07:19Z","image":"https://tuchuang.liushuiyu.cn/img/pid51%E5%B0%8F%E8%BD%A6.png","permalink":"https://blog.liushuiyu.cn/p/51%E8%93%9D%E7%89%99pid%E5%BE%AA%E8%BF%B9%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%80%A5%E5%81%9C%E9%81%BF%E9%9A%9C%E5%B0%8F%E8%BD%A6/","title":"51蓝牙PID循迹超声波急停避障小车"},{"content":"{% note info simple %}在Python中，变量的类型是动态的，这意味着你不需要在声明变量时指定类型，Python会根据变量的值自动确定其类型。{% endnote %}\n数据类型\r整数（int）：表示整数值，例如 1, 2, -5 等。 浮点数（float）：表示带有小数点的数值，例如 0.23, -4.56 等。 字符串（str）：表示文本数据，用单引号或双引号括起来，例如 \u0026lsquo;hello\u0026rsquo;, \u0026ldquo;world\u0026rdquo; 等。 布尔值（bool）：表示真或假，只有两个值：True 和 False。 列表（list）：表示有序的集合，可以包含不同类型的元素，用方括号括起来，例如 [1, 2, \u0026rsquo;three\u0026rsquo;, 4.0] 。 元组（tuple）：类似于列表，但是元素不能修改，用圆括号括起来，例如 (1, 2, \u0026rsquo;three\u0026rsquo;, 4.0) 。 字典（dict）：表示键值对的集合，用花括号括起来，例如 {\u0026rsquo;name\u0026rsquo;: \u0026lsquo;Alice\u0026rsquo;, \u0026lsquo;age\u0026rsquo;: 30} 。 集合（set）：表示无序不重复元素的集合，用花括号括起来，例如 {1, 2, 3} 。 变量的定义\r定义变量时，你只需要给变量赋一个值，Python会自动确定其类型： 1# 定义整数变量 2x = 10 3 4# 定义浮点数变量 5y = 3.14 6 7# 定义字符串变量 8name = \u0026#39;John\u0026#39; 9 10# 定义布尔变量 11is_true = True 12 13# 定义列表变量 14numbers = [1, 2, 3, 4, 5] 15 16# 定义元组变量 17point = (10, 20) 18 19# 定义字典变量 20person = {\u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;age\u0026#39;: 25} 21 22# 定义集合变量 23unique_numbers = {1, 2, 3, 2, 1} 在Python中，你可以使用内置函数来强制转换变量的类型：\nint(x)：将 x 转换为整数。 float(x)：将 x 转换为浮点数。 str(x)：将 x 转换为字符串。 list(x)：将 x 转换为列表（如果 x 是可迭代的）。 tuple(x)：将 x 转换为元组（如果 x 是可迭代的）。 dict(x)：将 x 转换为字典（如果 x 是键值对的迭代）。 set(x)：将 x 转换为集合（如果 x 是可迭代的）。 例如：\n1# 将浮点数转换为整数 2x = 3.99 3x_int = int(x) # x_int 的值为 3 4 5# 将整数转换为浮点数 6y = 5 7y_float = float(y) # y_float 的值为 5.0 8 9# 将整数转换为字符串 10z = 7 11z_str = str(z) # z_str 的值为 \u0026#39;7\u0026#39; 12 13# 将字符串转换为整数 14s = \u0026#39;123\u0026#39; 15s_int = int(s) # s_int 的值为 123 16 17# 将列表转换为元组 18lst = [1, 2, 3] 19lst_tuple = tuple(lst) # lst_tuple 的值为 (1, 2, 3) 20 21# 将元组转换为列表 22tpl = (4, 5, 6) 23tpl_list = list(tpl) # tpl_list 的值为 [4, 5, 6] 24 25# 将字典的键转换为集合 26dct = {\u0026#39;name\u0026#39;: \u0026#39;Bob\u0026#39;, \u0026#39;age\u0026#39;: 30} 27dct_keys_set = set(dct) # dct_keys_set 的值为 {\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;} 区别总结\r可变性 ：元组是不可变的，列表和集合是可变的。 有序性 ：列表和元组是有序的，集合是无序的。 重复性 ：列表和元组可以包含重复元素，集合不允许重复元素。 操作 ：列表和集合支持添加、删除和修改元素的操作，元组不支持这些操作。 用途 ：元组常用于表示不可变的数据集合，列表用于存储有序的数据集合，集合用于存储无序且不重复的数据集合。 注意，类型转换可能会导致数据丢失或不准确，例如将浮点数转换为整数时会丢失小数部分，将字符串转换为整数时如果字符串不是有效的整数表示则会引发错误。\n{% note info simple %}在Python中，空操作（pass）是一个占位符，它不执行任何操作。pass 语句在语法上是一个完整的语句，但在功能上是一个空操作。它的主要用途是在你需要一个语句的地方提供一个占位符，但暂时不实现任何功能。{% endnote %}\n空操作的意义：\r占位符：当你在编写代码时，可能需要先定义一个结构（如函数、类、循环、条件语句等），但还没有决定或实现具体的逻辑。使用 pass 可以避免语法错误，因为Python要求在这些结构中必须有语句。\n保持代码结构：在重构代码或设计API时，你可能需要先保持代码的结构完整，以便后续填充内容。\n避免编译错误：在某些情况下，如果你不提供一个语句，Python解释器会报错。pass 可以用来避免这种错误。\n空操作的运用：\r1# 在函数中使用 pass 2def my_function(): 3 pass # 这里暂时没有实现任何功能 4 5# 在类中使用 pass 6class MyClass: 7 pass # 这里暂时没有定义任何方法或属性 8 9# 在条件语句中使用 pass 10if condition: 11 pass # 如果条件为真，这里暂时没有执行任何操作 12else: 13 # 其他操作 14 pass 15 16# 在循环中使用 pass 17for item in my_list: 18 pass # 这里暂时没有对每个元素执行任何操作 空操作的进阶运用：\r占位符：在编写大型程序时，你可以使用 pass 来定义框架，然后逐步填充每个部分的逻辑。\n测试和调试：在调试代码时，你可以使用 pass 来临时禁用某些代码块，以便专注于其他部分的调试。\n设计模式：在某些设计模式中，如模板方法模式，你可以使用 pass 来定义抽象方法或钩子方法，这些方法在子类中被实现。\n代码文档：在编写代码文档时，你可以使用 pass 来表示某个部分是“待实现”的，这有助于其他开发者理解代码的当前状态。\n占位符变量：在某些情况下，你可能需要在代码中定义一个变量，但暂时不赋予它任何值。虽然这不是 pass 的直接用途，但你可以使用 pass 来初始化一个变量，例如 var = pass ，尽管这并不常见，也不推荐。\n总之，pass 是一个简单但非常有用的语句，它可以帮助你保持代码的结构完整性，同时允许你逐步实现代码的逻辑。\n","date":"2024-05-10T23:50:02Z","image":"https://tuchuang.liushuiyu.cn/img/py1.jpg","permalink":"https://blog.liushuiyu.cn/p/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---%E5%8F%98%E9%87%8F%E4%B8%8E%E7%A9%BA%E6%93%8D%E4%BD%9C/","title":"python学习笔记---变量与空操作"},{"content":"{% note info simple %}Python 是一种非常注重代码格式和缩进的编程语言。在 Python 中，缩进不仅仅是美观的考量，它实际上是语法的一部分，用来定义代码块的结构。正确的缩进对于 Python 代码的运行至关重要。{% endnote %}\n判断语句（条件语句）\rPython 中的判断语句使用 ***if、elif（可选）和 else（可选）***关键字。下面是一个基本的判断语句的例子：\n1# 单个 if 语句 2if condition: 3 # 如果 condition 为真，执行这里的代码块 4 pass 5 6# if-else 语句 7if condition: 8 # 如果 condition 为真，执行这里的代码块 9 pass 10else: 11 # 如果 condition 为假，执行这里的代码块 12 pass 13 14# if-elif-else 语句 15if condition1: 16 # 如果 condition1 为真，执行这里的代码块 17 pass 18elif condition2: 19 # 如果 condition1 为假且 condition2 为真，执行这里的代码块 20 pass 21else: 22 # 如果所有条件都为假，执行这里的代码块 23 pass 循环语句\rPython 中有两种循环语句：for循环和while循环。\nfor 循环\rfor循环用于遍历序列（如列表、元组、字符串等）或其他可迭代对象。\n在Python的for循环中，确实没有像C语言中那样的显式条件判断和自增/自减操作。Python的for循环是专门设计用来遍历可迭代对象（如列表、元组、字符串等）的，它会自动处理迭代过程，不需要手动设置初始条件、循环条件和更新表达式。\n1for 变量 in 可迭代对象: 2 # 循环体 在Python的for循环中，你不需要指定任何条件来控制循环的次数，因为循环次数是由可迭代对象的长度决定的。Python会自动遍历可迭代对象中的每个元素，并将当前元素赋值给循环变量，然后执行循环体。\n例如，如果你想遍历一个列表并打印每个元素，你可以这样做：\n1numbers = [1, 2, 3, 4, 5] 2for number in numbers: 3 print(number) 在这个例子中，for number in numbers: 会自动遍历列表 numbers中的每个元素，并将当前元素赋值给变量 number。循环体中的代码（即 print(number) ）会针对列表中的每个元素执行一次。\nwhile 循环\rwhile循环在条件为真时重复执行代码块。\n1while condition: 2 # 只要 condition 为真，就执行这里的代码块 3 pass 示例\r下面是一个使用 if 和 for 循环的简单示例：\n1# 遍历列表并打印每个元素 2numbers = [1, 2, 3, 4, 5] 3for number in numbers: 4 if number % 2 == 0: 5 print(f\u0026#34;{number} 是偶数\u0026#34;) 6 else: 7 print(f\u0026#34;{number} 是奇数\u0026#34;) ","date":"2024-05-10T13:38:46Z","image":"https://tuchuang.liushuiyu.cn/img/py2.jpg","permalink":"https://blog.liushuiyu.cn/p/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0---%E5%88%A4%E6%96%AD%E5%BE%AA%E7%8E%AF%E8%AF%AD%E6%B3%95/","title":"python学习笔记---判断循环语法"},{"content":" {% p blue, 安装虚拟机的目的 %}\r虚拟机是用主机的内存和CPU开辟出的一个独立不干扰的独立空间 这里就是一个小世界，可以是Windos，linux，mac的世界，也可以是你自己的世界。 在这，我们可以测试危险的软件，可以绕过诸多检查权限的软件，不用担心被病毒感染，也不\t用担心一些软件权限过大威胁到主机，因为虚拟机和主机是完全隔离开的，虚拟机也无法读取和调用主机的权限与功能，我们只需要对虚拟机进行删除镜像，就能又一切的恢复如初。\n{% p blue, 虚拟机安装 %}\r安装VMware 软件介绍：\nVMware是功能最强大的虚拟机软件，用户可以在虚拟机同时运行各种操作系统，进行开发、测试、演示和部署软件，虚拟机中复制服务器、台式机和平板环境，每个虚拟机可分配多个处理器核心、主内存和显存。\n具体安装教程\n密钥：\nVMware Workstation Pro 16 许可证密钥，批量永久激活 1ZF3R0-FHED2-M80TY-8QYGC-NPKYF 2YF390-0HF8P-M81RQ-2DXQE-M2UT6 3ZF71R-DMX85-08DQY-8YMNC-PPHV8 {% label 注意不同版本的VMware需要的密钥也不同 %}，不过这些都是可以能百度得到的密钥，无需花钱。\n{% p blue, 镜像 vmx的导入 %}\r安装好后只需要{% span red, 导入你要安装的系统镜像即可 %}，例如w11，w10，linux的镜像。\n当然也可以用已经做好的vmx。 这里就不赘诉了，百度一堆教程。\n那vmx又是什么？\n我们都知道，iso是系统的镜像文件，而vmx是VMware虚拟机配置，它是虚拟机系统文件，通常通过打开这个虚拟机文件以启动系统。同样，我们通过编辑它还可以实现某种配置需求，可以用文本文档的方式将其打开。\n这里分享一些vmx\nw7精简版阿里云盘\nw7简精版天翼网盘\nw7简精版百度网盘 提取码：goxv\nw10简精版 提取码:0537\n以上资源，皆来于网络无营利性分享。\n","date":"2024-05-09T15:33:49Z","image":"https://tuchuang.liushuiyu.cn/img/虚拟机安装.jpg","permalink":"https://blog.liushuiyu.cn/p/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85w7/w10%E4%BC%98%E5%8C%96%E7%B2%BE%E7%AE%80%E7%89%88/","title":"虚拟机安装W7/W10优化精简版"},{"content":"前言\r之前写过一篇基础教程，但是不够直白和连续，现 2024/12/31 对该文章重构。\n目的： 实现学习通等网课平台自动挂视频和答题\n对网课视频中的弹窗题目作答\n对课后习题自动作答，并设置正确率为界限提交\n自动复习，自动翻ppt\n可定义倍速，1倍数、2倍数、3倍数等\n原理： 通过浏览器加载扩展程序，用以启动js脚本。\n浏览器：Edg浏览器、火狐、谷歌 (三选一)\n扩展程序：油猴、脚本猫（二选一）\n开始\r下载扩展\r进入油猴官网，如图所示，先选择你的浏览器,这里我以Chrome（谷歌为例）\n然后下拉，找到下载这里， 这里有两种安装方案，具体如图所示，第一种方法简单快捷，就正常下载然后安装就行，但是对于网络有特殊要求，一般无法直连，需要梯子。 故此我们分类讲述。\n第一种方案\r点击去商店会跳转到chrome商店（因为我是谷歌浏览器，如果你是edg浏览器，就选择edg的，此时点击去商店就会跳转到对应的浏览器商店）\n这时候就可以看到我们已经安装成功了油猴\n第二种方案\r我们先下载好扩展程序，然后人为导入到浏览器的扩展里面。所以第一步，我们先直接下载这个扩展程序，下载好后要记住你下载的位置在哪。\n接着打开浏览器的设置，在设置里面找到扩展这一选项\n然后记得打开 开发者模式，开发者模式不打开的话是无法导入扩展的。\n接着就将我们刚刚下载好的扩展 直接拖到这里。\n然后会出现提示框询问你是否添加该扩展，选择添加扩展程序\n最后 我们就成功安装好了扩展了。\n安装网课脚本\r现在我们已经安装好了扩展，只需要再安装对应的脚本就行了。我这里推荐使用OSC网课助手。\n首先我们先进入脚本网站搜索我们要的OCS网课助手。\n然后安装该脚本 这时候会跳转到油猴这里，我们只需要再次点击安装就行。\r当你点击安装，安装完成后会自动关闭该界面，并且速度很快，这是正常现象，我们可以去到油猴管理界面看看我们的脚本是否安装成功。点击油猴，找到管理面板，进入其中。\r可以看到，我们是已经成功安装好了该网课脚本。\r当然，当你安装好了该网课脚本，你也可以直接进入学习通，这时候会有对应脚本的出现。\n配置题库\r配置题库教程参考言溪题库官方教程 我在此阐述一下油猴扩展、OCS网课助手、言溪题库之间的关系及其各作用。\n油猴扩展程序：作为浏览器的扩展程序，可以运行各种脚本实现不同功能，如果刷网课，屏蔽广告等等\nOCS网课助手：脚本文件，要想运行在浏览器上面需要用到扩展程序如油猴、脚本猫，该助手全部功能免费，可以自动刷网课，但是无法答题，因为答题需要向题库查询对应题目，如果你没题库，就需要用别人的题库，这也是为什么我会提到言溪题库。\n言溪题库：就是题库，里面有很多的题目。具体可以去官方详情里看。\n结语\r如果你只是想刷完课程时间，而不想答题，那么题库是可以不用配置的。\n这篇教程算是完结了，算是比上次写的更通俗一点。\n","date":"2024-05-05T20:18:12Z","image":"https://tuchuang.liushuiyu.cn/img/网课.jpg","permalink":"https://blog.liushuiyu.cn/p/ocs%E7%BD%91%E8%AF%BE%E5%8A%A9%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%BD%91%E8%AF%BE%E8%87%AA%E5%8A%A8%E5%88%B7%E8%AF%BE/","title":"OCS网课助手实现网课自动刷课"}]